/** OPENLAYERS ADAPTATION
 * © Dominique Cavailhez 2017
 * https://github.com/Dominique92/MyOl
 * Based on https://openlayers.org
 *
 * This file has been generated by build.php from the src/... sources
 * Please don't modify it : modify src/... & rebuild it !
 */

/* FILE src/header.js */
// Validators adapters
/* jshint esversion: 6 */
if (!ol) var ol = {};

/**
 * Debug facilities on mobile
 */
if (!location.hash.indexOf('##'))
	window.addEventListener('error', function(evt) {
		alert(evt.filename + ' ' + evt.lineno + ':' + evt.colno + '\n' + evt.message);
	});
if (location.hash == '###')
	console.log = function(message) {
		alert(message);
	};

/**
 * Display misc values
 */
// OL version
try {
	new ol.style.Icon(); // Try incorrect action
} catch (err) { // to get Assert url
	console.log('Ol ' + err.message.match('/v([0-9\.]+)/')[1]);
}
// localStorage
let localStorageDump = [];
for (let i = 0; i < localStorage.length; i++) {
	localStorageDump.push(
		localStorage.key(i) + ': ' +
		localStorage.getItem(localStorage.key(i)));
}
console.log(localStorageDump.join('\n'));

/**
 * Warn layers when added to the map
 */
ol.Map.prototype.handlePostRender = function() {
	ol.PluggableMap.prototype.handlePostRender.call(this);

	const map = this;
	map.getLayers().forEach(function(layer) {
		if (!layer.map_) {
			layer.map_ = map;

			layer.dispatchEvent({
				type: 'myol:onadd',
				map: map,
			});
		}
	});
};

/**
 * Json parsing errors log
 */
function JSONparse(json) {
	try {
		return JSON.parse(json);
	} catch (returnCode) {
		console.log(returnCode + ' parsing : "' + json + '" ' + new Error().stack);
	}
}

/**
 * IOS 12 support
 */
if (window.PointerEvent === undefined) {
	const script = document.createElement('script');
	script.src = 'https://unpkg.com/elm-pep';
	document.head.appendChild(script);
}
// Icon extension depending on the OS (IOS 12 dosn't support SVG)
function iconCanvasExt() {
	const iOSVersion = navigator.userAgent.match(/iPhone OS ([0-9]+)/);
	return iOSVersion && iOSVersion[1] < 13 ? 'png' : 'svg';
}

/* FILE src/layerTileCollection.js */
/**
 * This module defines many WMTS EPSG:3857 tiles layers
 */

/**
 * Openstreetmap
 */
function layerOSM(url, attribution, maxZoom) {
	return new ol.layer.Tile({
		source: new ol.source.XYZ({
			url: url,
			maxZoom: maxZoom || 21,
			attributions: [
				attribution || '',
				ol.source.OSM.ATTRIBUTION,
			],
		}),
	});
}

function layerOpenTopo() {
	return layerOSM(
		'//{a-c}.tile.opentopomap.org/{z}/{x}/{y}.png',
		'<a href="https://opentopomap.org">OpenTopoMap</a> ' +
		'(<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)',
		17
	);
}

function layerMRI() {
	return layerOSM(
		'//maps.refuges.info/hiking/{z}/{x}/{y}.png',
		'<a href="//wiki.openstreetmap.org/wiki/Hiking/mri">Refuges.info</a>'
	);
}

/**
 * Kompas (Austria)
 * Requires layerOSM
 */
function layerKompass(subLayer) {
	return layerOSM(
		'https://chemineur.fr/assets/proxy/?s=ecmaps.de&type=x-icon' + // Not available via https
		'&Experience=ecmaps&MapStyle=' + subLayer + '&TileX={x}&TileY={y}&ZoomLevel={z}',
		'<a href="http://www.kompass.de/livemap/">KOMPASS</a>'
	);
}

/**
 * Thunderforest
 * Requires layerOSM
 * var mapKeys.thunderforest = Get your own (free) THUNDERFOREST key at https://manage.thunderforest.com
 */
function layerThunderforest(subLayer) {
	if (typeof mapKeys == 'undefined' || !mapKeys) mapKeys = {};

	if (mapKeys.thunderforest)
		return layerOSM(
			'//{a-c}.tile.thunderforest.com/' + subLayer +
			'/{z}/{x}/{y}.png?apikey=' + mapKeys.thunderforest,
			'<a href="http://www.thunderforest.com">Thunderforest</a>'
		);
}

/**
 * Google
 */
function layerGoogle(subLayer) {
	return new ol.layer.Tile({
		source: new ol.source.XYZ({
			url: '//mt{0-3}.google.com/vt/lyrs=' + subLayer + '&hl=fr&x={x}&y={y}&z={z}',
			attributions: '&copy; <a href="https://www.google.com/maps">Google</a>',
		}),
	});
}

/**
 * Stamen http://maps.stamen.com
 */
function layerStamen(subLayer, minResolution) {
	return new ol.layer.Tile({
		source: new ol.source.Stamen({
			layer: subLayer,
		}),
		minResolution: minResolution || 0,
	});
}

/**
 * IGN France
 * var mapKeys.ign = Get your own (free)IGN key at https://geoservices.ign.fr/
 * doc : https://geoservices.ign.fr/services-web
 */
function layerIGN(options) {
	options = Object.assign({
		format: 'image/jpeg',
		style: 'normal',
	}, options);

	let IGNresolutions = [],
		IGNmatrixIds = [];

	for (let i = 0; i < 18; i++) {
		IGNresolutions[i] = ol.extent.getWidth(ol.proj.get('EPSG:3857').getExtent()) / 256 / Math.pow(2, i);
		IGNmatrixIds[i] = i.toString();
	}

	return new ol.layer.Tile({
		source: new ol.source.WMTS(Object.assign({
			url: 'https://wxs.ign.fr/' + options.key + '/wmts',
			matrixSet: 'PM',
			tileGrid: new ol.tilegrid.WMTS({
				origin: [-20037508, 20037508],
				resolutions: IGNresolutions,
				matrixIds: IGNmatrixIds,
			}),
			attributions: '&copy; <a href="http://www.geoportail.fr/" target="_blank">IGN</a>',
		}, options)),
	});
}

/**
 * Swisstopo https://api.geo.admin.ch/
 */
function layerSwissTopo(layer1) {
	const projectionExtent = ol.proj.get('EPSG:3857').getExtent(),
		resolutions = [],
		matrixIds = [];

	for (let r = 0; r < 18; ++r) {
		resolutions[r] = ol.extent.getWidth(projectionExtent) / 256 / Math.pow(2, r);
		matrixIds[r] = r;
	}

	return [
		layerStamen('terrain', 300),
		new ol.layer.Tile({
			maxResolution: 300,
			source: new ol.source.WMTS(({
				crossOrigin: 'anonymous',
				url: '//wmts2{0-4}.geo.admin.ch/1.0.0/' + layer1 + '/default/current/3857/{TileMatrix}/{TileCol}/{TileRow}.jpeg',
				tileGrid: new ol.tilegrid.WMTS({
					origin: ol.extent.getTopLeft(projectionExtent),
					resolutions: resolutions,
					matrixIds: matrixIds,
				}),
				requestEncoding: 'REST',
				attributions: '&copy <a href="https://map.geo.admin.ch/">SwissTopo</a>',
			})),
		}),
	];
}

/**
 * Spain
 */
function layerSpain(server, subLayer) {
	return new ol.layer.Tile({
		source: new ol.source.XYZ({
			url: '//www.ign.es/wmts/' + server + '?layer=' + subLayer +
				'&Service=WMTS&Request=GetTile&Version=1.0.0&Format=image/jpeg' +
				'&style=default&tilematrixset=GoogleMapsCompatible' +
				'&TileMatrix={z}&TileCol={x}&TileRow={y}',
			attributions: '&copy; <a href="http://www.ign.es/">IGN España</a>',
		}),
	});
}

/**
 * Italy IGM
 */
function layerIGM() {
	return [
		subLayerIGM('IGM_25000', 'CB.IGM25000', 5, 10),
		subLayerIGM('IGM_100000', 'MB.IGM100000', 10, 20),
		subLayerIGM('IGM_250000', 'CB.IGM250000', 20, 120),
		layerStamen('terrain', 120),
	];

	function subLayerIGM(url, layer, minResolution, maxResolution) {
		return new ol.layer.Tile({
			minResolution: minResolution,
			maxResolution: maxResolution,
			source: new ol.source.TileWMS({
				url: 'https://chemineur.fr/assets/proxy/?s=minambiente.it&type=png' + // Not available via https
					'&map=/ms_ogc/WMS_v1.3/raster/' + url + '.map',
				params: {
					layers: layer,
				},
				attributions: '&copy <a href="http://www.pcn.minambiente.it/viewer/">IGM</a>',
			}),
		});
	}
}

/**
 * Ordnance Survey : Great Britain
 * var mapKeys.os = Get your own (free) key at https://osdatahub.os.uk/
 */
function layerOS(subLayer) {
	if (typeof mapKeys == 'undefined' || !mapKeys) mapKeys = {};

	if (mapKeys.os)
		return [
			layerStamen('terrain', 1700),
			new ol.layer.Tile({
				extent: [-1198263, 6365000, 213000, 8702260],
				minResolution: 2,
				maxResolution: 1700,
				source: new ol.source.XYZ({
					url: 'https://api.os.uk/maps/raster/v1/zxy/' + subLayer +
						'/{z}/{x}/{y}.png?key=' + mapKeys.os,
					attributions: '&copy <a href="https://explore.osmaps.com">UK Ordnancesurvey maps</a>',
				}),
			}),
		];
}

/**
 * Bing (Microsoft)
 * var mapKeys.bing = Get your own (free) key at https://docs.microsoft.com/en-us/bingmaps/getting-started/
 */
function layerBing(subLayer) {
	if (typeof mapKeys == 'undefined' || !mapKeys) mapKeys = {};

	if (mapKeys.bing) {
		const layer = new ol.layer.Tile();

		layer.on('change:visible', function() {
			if (!layer.getSource()) {
				layer.setSource(new ol.source.BingMaps({
					imagerySet: subLayer,
					key: mapKeys.bing,
				}));
			}
		});

		return layer;
	}
}

/**
 * Tile layers examples
 */
function layersCollection() {
	return {
		'OpenTopo': layerOpenTopo(),
		'OSM outdoors': layerThunderforest('outdoors'),
		'OSM transport': layerThunderforest('transport'),
		'Refuges.info': layerMRI(),
		'OSM fr': layerOSM('//{a-c}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png'),
		'IGN TOP25': layerIGN({
			layer: 'GEOGRAPHICALGRIDSYSTEMS.MAPS',
			key: mapKeys.ign,
		}),
		'IGN V2': layerIGN({
			layer: 'GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2',
			key: 'essentiels',
			format: 'image/png',
		}),
		'IGN cartes 1950': layerIGN({
			layer: 'GEOGRAPHICALGRIDSYSTEMS.MAPS.SCAN50.1950',
			key: 'cartes/geoportail',
		}),
		'IGN E.M. 1820-66': layerIGN({
			layer: 'GEOGRAPHICALGRIDSYSTEMS.ETATMAJOR40',
			key: 'cartes/geoportail',
		}),
		/*'IGN Cassini': layerIGN({
			layer:'GEOGRAPHICALGRIDSYSTEMS.CASSINI',
			key: 'x7yv499pbcguxhhxh8syehwe/geoportail',
		}),*/
		'SwissTopo': layerSwissTopo('ch.swisstopo.pixelkarte-farbe'),
		'Autriche': layerKompass('KOMPASS Touristik'),
		'Angleterre': layerOS('Outdoor_3857'),
		'Italie': layerIGM(),
		'Espagne': layerSpain('mapa-raster', 'MTN'),
		'Photo IGN': layerIGN({
			layer: 'ORTHOIMAGERY.ORTHOPHOTOS',
			key: 'essentiels',
		}),
		'Photo IGN 1950-65': layerIGN({
			layer: 'ORTHOIMAGERY.ORTHOPHOTOS.1950-1965',
			key: 'orthohisto/geoportail',
			style: 'BDORTHOHISTORIQUE',
			format: 'image/png',
		}),
		'Photo Bing': layerBing('Aerial'),
		'Photo Google': layerGoogle('s'),
	};
}

function layersDemo() {
	return Object.assign(layersCollection(), {
		'OSM': layerOSM('//{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'),
		'OSM cyclo': layerOSM('//{a-c}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png'),

		'ThF cycle': layerThunderforest('cycle'),
		'ThF landscape': layerThunderforest('landscape'),
		'ThF trains': layerThunderforest('pioneer'),
		'ThF villes': layerThunderforest('neighbourhood'),
		'ThF contraste': layerThunderforest('mobile-atlas'),

		'OS light': layerOS('Light_3857'),
		'OS road': layerOS('Road_3857'),
		'Kompas': layerKompass('KOMPASS'),

		'Bing': layerBing('Road'),
		'Bing hybrid': layerBing('AerialWithLabels'),

		'Photo Swiss': layerSwissTopo('ch.swisstopo.swissimage'),
		'Photo Espagne': layerSpain('pnoa-ma', 'OI.OrthoimageCoverage'),

		'Google road': layerGoogle('m'),
		'Google terrain': layerGoogle('p'),
		'Google hybrid': layerGoogle('s,h'),
		'Stamen': layerStamen('terrain'),
		'Toner': layerStamen('toner'),
		'Watercolor': layerStamen('watercolor'),
		'Blank': new ol.layer.Tile(),
	});
}

/* FILE src/layerSwitcher.js */
/**
 * Layer switcher
 * Need to include layerSwitcher.css
 */
function controlLayerSwitcher(baseLayers, options) {
	baseLayers = baseLayers || layersCollection();
	options = options || {};

	const control = new ol.control.Control({
			element: document.createElement('div'),
		}),
		layerNames = Object.keys(baseLayers),
		baselayer = location.href.match(/baselayer=([^\&]+)/);
	let transparentBaseLayerName = '';

	// Get baselayer from url ?
	if (baselayer)
		localStorage.myol_baselayer = decodeURI(baselayer[1]);

	// Build html transparency slider
	const rangeContainerEl = document.createElement('div');
	rangeContainerEl.innerHTML =
		'<input type="range" id="layerSlider" title="Glisser pour faire varier la tranparence">' +
		'<span>Ctrl+click: multicouches</span>';
	rangeContainerEl.firstChild.oninput = displayTransparencyRange;

	control.setMap = function(map) {
		ol.control.Control.prototype.setMap.call(this, map);

		// control.element is defined when attached to the map
		control.element.className = 'ol-control ol-control-switcher';
		control.element.innerHTML = '<button><i>&#x274F;</i></button>';
		control.element.appendChild(rangeContainerEl);
		control.element.onmouseover = function() {
			control.element.classList.add('ol-control-switcher-open');
		};

		// Hide the selector when the cursor is out of the selector
		map.on('pointermove', function(evt) {
			const max_x = map.getTargetElement().offsetWidth - control.element.offsetWidth - 20,
				max_y = control.element.offsetHeight + 20;

			if (evt.pixel[0] < max_x || evt.pixel[1] > max_y)
				control.element.classList.remove('ol-control-switcher-open');
		});

		// Build html baselayers selectors
		for (let name in baseLayers)
			if (baseLayers[name]) { // Don't dispatch null layers (whose declaraton failed)
				// Make all choices an array of layers
				if (!baseLayers[name].length)
					baseLayers[name] = [baseLayers[name]];

				const selectionEl = document.createElement('div'),
					inputId = 'l' + baseLayers[name][0].ol_uid + (name ? '-' + name : '');

				control.element.appendChild(selectionEl);
				selectionEl.innerHTML =
					'<input type="checkbox" name="baseLayer ' +
					'"id="' + inputId + '" value="' + name + '" ' + ' />' +
					'<label for="' + inputId + '">' + name + '</label>';
				selectionEl.firstChild.onclick = selectBaseLayer;
				baseLayers[name].inputEl = selectionEl.firstChild; // Mem it for further ops

				for (let l = 0; l < baseLayers[name].length; l++) {
					baseLayers[name][l].setVisible(false); // Don't begin to get the tiles yet
					map.addLayer(baseLayers[name][l]);
				}
			}

		displayBaseLayers(); // Init layers

		// Attach html additional selector
		const additionalSelector = document.getElementById(
			options.additionalSelectorId ||
			'additional-selector'
		);

		if (additionalSelector) {
			control.element.appendChild(additionalSelector);
			// Unmask the selector if it has been @ the declaration
			additionalSelector.style.display = '';
		}
	};

	function selectBaseLayer(evt) {
		// 1 seule couche
		if (!evt || !evt.ctrlKey || this.value == localStorage.myol_baselayer) {
			transparentBaseLayerName = '';
			localStorage.myol_baselayer = this.value;
		}
		// Il y a une deuxième couche aprés celle existante
		else if (layerNames.indexOf(localStorage.myol_baselayer) <
			layerNames.indexOf(this.value)) {
			transparentBaseLayerName = this.value;
			// localStorage.myol_baselayer don't change
		}
		// Il y a une deuxième couche avant celle existante
		else {
			transparentBaseLayerName = localStorage.myol_baselayer;
			localStorage.myol_baselayer = this.value;
		}

		rangeContainerEl.firstChild.value = 50;
		displayBaseLayers();
	}

	function displayBaseLayers() {
		// Baselayer default is the first of the selection
		if (!baseLayers[localStorage.myol_baselayer])
			localStorage.myol_baselayer = Object.keys(baseLayers)[0];

		for (let name in baseLayers)
			if (baseLayers[name]) {
				const visible =
					name == localStorage.myol_baselayer ||
					name == transparentBaseLayerName;

				// Write the checks
				baseLayers[name].inputEl.checked = visible;

				// Make the right layers visible
				for (let l = 0; l < baseLayers[name].length; l++) {
					baseLayers[name][l].setVisible(visible);
					baseLayers[name][l].setOpacity(1);
				}
			}

		displayTransparencyRange();
	}

	function displayTransparencyRange() {
		if (transparentBaseLayerName) {
			for (let l = 0; l < baseLayers[transparentBaseLayerName].length; l++)
				baseLayers[transparentBaseLayerName][l].setOpacity(
					rangeContainerEl.firstChild.value / 100
				);

			rangeContainerEl.className = 'double-layer';
		} else
			rangeContainerEl.className = 'single-layer';
	}

	return control;
}

/* FILE src/layerVector.js */
/**
 * This file adds some facilities to ol.layer.Vector
 */

/**
 * Layer to display remote geoJson
 * Styles, icons & labels
 *
 * Options:
 * selectorName : <input name="SELECTORNAME"> url arguments selector
 * selectorName : <TAG id="SELECTORNAME-status"></TAG> display loading status
 * urlFunction: function(options, bbox, selection, extent, resolution, projection) returning the XHR url
 * convertProperties: function(properties, feature, options) who extract a list of data from the XHR to be available as feature.display.XXX
 * styleOptionsFunction: function(feature, properties, options) returning options of the style of the features
 * styleOptionsClusterFunction: function(feature, properties, options) returning options of the style of the cluster bullets
 * hoverStyleOptionsFunction: function(feature, properties, options) returning options of the style when hovering the features
 * source.Vector options : format, strategy, attributions, ...
 */
function layerVector(opt) {
	const options = Object.assign({
			zIndex: 10, // Features : above the base layer (zIndex = 1)
			format: new ol.format.GeoJSON(),
			strategy: ol.loadingstrategy.bbox,
			styleOptionsClusterFunction: styleOptionsCluster,
		}, opt),

		// Source & layer
		source = new ol.source.Vector(Object.assign({
			url: url,
		}, options)),

		layer = new ol.layer.Vector(Object.assign({
			source: source,
			style: style,
		}, options)),

		elLabel = document.createElement('span'),
		statusEl = document.getElementById(options.selectorName + '-status'); // XHR download tracking

	if (statusEl)
		source.on(['featuresloadstart', 'featuresloadend', 'featuresloaderror'], function(evt) {
			if (!statusEl.textContent.includes('error'))
				statusEl.textContent = '';

			switch (evt.type) {
				case 'featuresloadstart':
					statusEl.textContent = 'Chargement...';
					break;
				case 'featuresloaderror':
					statusEl.textContent = 'Erreur !';
			}
		});

	// url callback function for the layer
	function url(extent, resolution, projection) {
		const selection = readCheckbox(options.selectorName);

		return options.urlFunction(
			options, // Layer options
			ol.proj.transformExtent( // BBox
				extent,
				projection.getCode(), // Map projection
				'EPSG:4326' // Received projection
			).map(function(c) {
				return c.toFixed(4); // Round to 4 digits
			}),
			typeof selection == 'object' ? selection : [],
			extent, resolution, projection
		);
	}

	// Modify a geoJson url argument depending on checkboxes
	memCheckbox(options.selectorName, function(selection) {
		const visible = typeof selection == 'object' ? selection.length : selection === true;

		layer.setVisible(visible);
		if (visible)
			source.refresh();
	});

	// Callback function to define feature display from the properties received from the server
	source.on('featuresloadend', function(evt) {
		for (let f in evt.features) {
			// These options will be displayed by the hover response
			evt.features[f].hoverStyleOptionsFunction = options.hoverStyleOptionsFunction;

			// Compute data to be used to display the feature
			evt.features[f].display = typeof options.convertProperties == 'function' ?
				options.convertProperties(
					evt.features[f].getProperties(),
					evt.features[f],
					options
				) : {};

			// Detect lines or polygons
			evt.features[f].display.area =
				ol.extent.getArea(evt.features[f].getGeometry().getExtent());
		}
	});

	// Style callback function for the layer
	function style(feature) {
		const properties = feature.getProperties();

		return displayStyle(
			feature,
			properties.features || properties.cluster ?
			options.styleOptionsClusterFunction :
			options.styleOptionsFunction
		);
	}

	// Function to display different styles
	function displayStyle(feature, styleOptionsFunction) {
		if (typeof styleOptionsFunction == 'function') {
			const styleOptions = styleOptionsFunction(
				feature, Object.assign(feature.getProperties(),
					feature.display),
				options
			);

			if (styleOptions && styleOptions.text) {
				elLabel.innerHTML = styleOptions.text.getText();

				if (elLabel.innerHTML) {
					styleOptions.text.setText(
						elLabel.textContent[0].toUpperCase() + elLabel.textContent.substring(1)
					);
				}
			}

			return new ol.style.Style(styleOptions);
		}
	}

	// Display labels on hovering & click
	// on features of vector layers having the following properties :
	// hover : text on top of the picture
	// url : go to a new URL when we click on the feature

	ol.Map.prototype.render = function() {
		if (!this.hoverListenerInstalled && this.getView()) {
			this.hoverListenerInstalled = true;
			initHover(this);
		}

		return ol.PluggableMap.prototype.render.call(this);
	};

	function initHover(map) {
		// Layer to display an hovered features
		const hoverSource = new ol.source.Vector(),
			hoverLayer = new ol.layer.Vector({
				source: hoverSource,
				zIndex: 30, // Hover : above the the features
				style: function(feature) {
					return displayStyle(feature, feature.hoverStyleOptionsFunction);
				},
			});

		map.addLayer(hoverLayer);

		// Leaving the map reset hovering
		window.addEventListener('mousemove', function(evt) {
			const divRect = map.getTargetElement().getBoundingClientRect();

			// The mouse is outside of the map
			if (evt.clientX < divRect.left || divRect.right < evt.clientX ||
				evt.clientY < divRect.top || divRect.bottom < evt.clientY)
				mouseEvent({});
		});

		map.on(['pointermove', 'click'], mouseEvent);
		map.getView().on('change:resolution', mouseEvent); // For WRI massifs

		function mouseEvent(evt) {
			const originalEvent = evt.originalEvent || evt,
				// Get the hovered feature
				feature = map.forEachFeatureAtPixel(
					map.getEventPixel(originalEvent),
					function(feature) {
						return feature;
					}, {
						hitTolerance: 6, // Default 0
					});

			// Update the display of hovered feature
			if (map.hoveredFeature !== feature && !options.noLabel) {
				if (map.hoveredFeature)
					hoverSource.clear();

				if (feature)
					hoverSource.addFeature(feature);

				map.hoveredFeature = feature;
			}

			if (feature && !options.noClick) {
				const features = feature.get('features') || [feature],
					display = Object.assign({},
						features[0].getProperties(), // Get first or alone feature
						features[0].display
					),
					geom = feature.getGeometry();

				// Set the cursor if hover a clicable feature
				map.getViewport().style.cursor = display.url || display.cluster ? 'pointer' : '';

				// Click actions
				if (evt.type == 'click' && display) {
					if (features.length == 1 && display.url) {
						// Single feature
						if (originalEvent.ctrlKey)
							window.open(display.url, '_blank').focus();
						else
						if (originalEvent.shiftKey)
							// To specify feature open a new window
							window.open(display.url, '_blank', 'resizable=yes').focus();
						else
							location.replace(display.url);
					}
					// Cluster
					else if (geom && (features.length > 1 || display.cluster))
						map.getView().animate({
							zoom: map.getView().getZoom() + 2,
							center: geom.getCoordinates(),
						});
				}
			} else
				map.getViewport().style.cursor = '';
		}
	}

	return layer;
}

/**
 * Clustering features
 */
function layerVectorCluster(options) {
	// Detailed layer
	const layer = layerVector(options);

	// No clustering
	if (!options.distance)
		return layer;

	// Clusterized source
	const clusterSource = new ol.source.Cluster({
			source: layer.getSource(),
			distance: options.distance,
			geometryFunction: geometryFunction,
			createCluster: createCluster,
		}),

		// Clusterized layer
		clusterLayer = new ol.layer.Vector(Object.assign({
			source: clusterSource,
			style: clusterStyle,
			visible: layer.getVisible(),
			zIndex: layer.getZIndex(),
		}, options));

	// Propagate setVisible following the selector status
	layer.on('change:visible', function() {
		clusterLayer.setVisible(this.getVisible());
	});

	// Tune the clustering distance depending on the zoom level
	let previousResolution;
	clusterLayer.on('prerender', function(evt) {
		const resolution = evt.frameState.viewState.resolution,
			distance = resolution < 10 ? 0 : Math.min(options.distance, resolution);

		if (previousResolution != resolution) // Only when changed
			clusterSource.setDistance(distance);

		previousResolution = resolution;
	});

	// Generate a center point to manage clusterisations
	function geometryFunction(feature) {
		const extent = feature.getGeometry().getExtent(),
			pixelSemiPerimeter = (extent[2] - extent[0] + extent[3] - extent[1]) / this.resolution;

		// Don't cluster lines or polygons whose the extent perimeter is more than 400 pixels
		if (pixelSemiPerimeter > 200)
			clusterSource.addFeature(feature);
		else
			return new ol.geom.Point(
				ol.extent.getCenter(
					feature.getGeometry().getExtent()
				)
			);
	}

	// Generate the features to render the cluster
	function createCluster(point, features) {
		// Single feature : display it
		if (features.length == 1)
			return features[0];

		// Display a cluster point
		return new ol.Feature({
			geometry: point,
			features: features
		});
	}

	// Style callback function for the layer
	function clusterStyle(feature, resolution) {
		const features = feature.get('features'),
			style = layer.getStyleFunction();

		if (features)
			feature.hoverStyleOptionsFunction = options.hoverStyleOptionsFunction;

		return style(feature, resolution);
	}

	return clusterLayer;
}

/**
 * Get checkboxes values of inputs having the same name
 * selectorName {string}
 * Return an array of the selected inputs
 */
function readCheckbox(selectorName, withOn) {
	const inputEls = document.getElementsByName(selectorName);

	// Specific case of a single on/off <input>
	if (inputEls.length == 1)
		return inputEls[0].checked ? [inputEls[0].value] : [];

	// Read each <input> checkbox
	const selection = [];
	for (let e = 0; e < inputEls.length; e++)
		if (inputEls[e].checked &&
			(inputEls[e].value != 'on' || withOn)) // Avoid the first check in a list
			selection.push(inputEls[e].value);

	return selection;
}

/**
 * Manage checkbox inputs having the same name
 * selectorName {string}
 * callback {function(selection)} action when the button is clicked
 *
 * Mem / recover the checkboxes in localStorage, url args or hash
 * Manages a global flip-flop of the same named <input> checkboxes
 */
function memCheckbox(selectorName, callback) {
	const inputEls = document.getElementsByName(selectorName),
		values = typeof localStorage['myol_' + selectorName] != 'undefined' ?
		localStorage['myol_' + selectorName] :
		readCheckbox(selectorName, true).join(',');

	// Set the <inputs> accordingly with the localStorage or url args
	if (inputEls)
		for (let e = 0; e < inputEls.length; e++) {
			// Set inputs following localStorage & args
			inputEls[e].checked =
				values.indexOf(inputEls[e].value) != -1 || // That one is declared
				values.split(',').indexOf('on') != -1; // The "all" (= "on") is set

			// Compute the all check && init the localStorage if data has been given by the url
			checkEl(inputEls[e]);

			// Attach the action
			inputEls[e].addEventListener('click', onClick);
		}

	function onClick(evt) {
		checkEl(evt.target); // Do the "all" check verification

		// Mem the data in the localStorage
		const selection = readCheckbox(selectorName);

		if (selectorName)
			localStorage['myol_' + selectorName] = typeof selection == 'object' ? selection.join(',') : selection ? 'on' : '';

		if (inputEls.length && typeof callback == 'function')
			callback(selection);
	}

	// Check on <input> & set the "All" input accordingly
	function checkEl(target) {
		let allIndex = -1, // Index of the "all" <input> if any
			allCheck = true; // Are all others checked ?

		for (let e = 0; e < inputEls.length; e++) {
			if (target.value == 'on') // If the "all" <input> is checked (who has a default value = "on")
				inputEls[e].checked = target.checked; // Force all the others to the same
			else if (inputEls[e].value == 'on') // The "all" <input>
				allIndex = e;
			else if (!inputEls[e].checked)
				allCheck = false; // Uncheck the "all" <input> if one other is unchecked
		}

		// Check the "all" <input> if all others are
		if (allIndex != -1)
			inputEls[allIndex].checked = allCheck;
	}

	const selection = readCheckbox(selectorName);

	if (inputEls.length && typeof callback == 'function')
		callback(selection);

	return selection;
}

/**
 * BBOX strategy when the url returns a limited number of features in the BBox
 * We do need to reload when the zoom in
 */
ol.loadingstrategy.bboxLimit = function(extent, resolution) {
	if (this.bboxLimitResolution > resolution) // When zoom in
		this.refresh(); // Force the loading of all areas
	this.bboxLimitResolution = resolution; // Mem resolution for further requests
	return [extent];
};

/**
 * Some usefull style functions
 */
// Get icon from an URL
function styleOptionsIcon(iconUrl) {
	if (iconUrl)
		return {
			image: new ol.style.Icon({
				src: iconUrl,
			}),
		};
}

// Get icon from chemineur.fr
function styleOptionsIconChemineur(iconName) {
	if (iconName) {
		const icons = iconName.split(' ');

		iconName = icons[0] + (icons.length > 1 ? '_' + icons[1] : ''); // Limit to 2 type names & ' ' -> '_'

		return styleOptionsIcon('//chemineur.fr/ext/Dominique92/GeoBB/icones/' + iconName + '.' + iconCanvasExt());
	}
}

// Display a label with some data about the feature
function styleOptionsFullLabel(properties) {
	let text = [],
		line = [];

	// Cluster
	if (properties.features || properties.cluster) {
		let includeCluster = !!properties.cluster;

		for (let f in properties.features) {
			const name = properties.features[f].getProperties().name || properties.features[f].display.name;
			if (name)
				text.push(name);
			if (properties.features[f].getProperties().cluster)
				includeCluster = true;
		}
		if (text.length == 0 || text.length > 6 || includeCluster)
			text = ['Cliquer pour zoomer'];
	}
	// Feature
	else {
		// 1st line
		if (properties.name)
			text.push(properties.name);

		// 2nd line
		if (properties.ele)
			line.push(parseInt(properties.ele) + ' m');
		if (properties.capacity)
			line.push(parseInt(properties.capacity) + '\u255E\u2550\u2555');
		if (line.length)
			text.push(line.join(', '));

		// 3rd line
		if (typeof properties.type == 'string' && properties.type)
			text.push(
				properties.type[0].toUpperCase() +
				properties.type.substring(1).replace('_', ' ')
			);

		// 4rd line
		if (properties.attribution)
			text.push('&copy;' + properties.attribution);
	}

	return styleOptionsLabel(text.join('\n'), properties, true);
}

// Display a label with only the name
function styleOptionsLabel(text, properties, important) {
	const styleTextOptions = {
		text: text,
		font: '14px Calibri,sans-serif',
		padding: [1, 1, 0, 3],
		fill: new ol.style.Fill({
			color: 'black',
		}),
		backgroundFill: new ol.style.Fill({
			color: 'white',
		}),
		backgroundStroke: new ol.style.Stroke({
			color: 'blue',
			width: important ? 1 : 0.3,
		}),
		overflow: important,
	};

	// For points
	if (!properties.area)
		Object.assign(styleTextOptions, {
			textBaseline: 'bottom',
			offsetY: -14, // Above the icon
		});

	return {
		text: new ol.style.Text(styleTextOptions),
		zIndex: 40, // Label : above the the features & editor
	};
}

// Apply a color and transparency to a polygon
function styleOptionsPolygon(color, transparency) { // color = #rgb, transparency = 0 to 1
	if (color)
		return {
			fill: new ol.style.Fill({
				color: 'rgba(' + [
					parseInt(color.substring(1, 3), 16),
					parseInt(color.substring(3, 5), 16),
					parseInt(color.substring(5, 7), 16),
					transparency || 1,
				].join(',') + ')',
			})
		};
}

// Style of a cluster bullet (both local & server cluster
function styleOptionsCluster(feature, properties) {
	let nbClusters = parseInt(properties.cluster || 0);

	for (let f in properties.features)
		nbClusters += parseInt(properties.features[f].getProperties().cluster || 1);

	return {
		image: new ol.style.Circle({
			radius: 14,
			stroke: new ol.style.Stroke({
				color: 'blue',
			}),
			fill: new ol.style.Fill({
				color: 'white',
			}),
		}),
		text: new ol.style.Text({
			text: nbClusters.toString(),
			font: '14px Calibri,sans-serif',
		}),
	};
}

/* FILE src/layerVectorCollection.js */
/**
 * This file implements various acces to geoJson services
 * using MyOl/src/layerVector.js
 */

/**
 * Site chemineur.fr, alpages.info
 * subLayer: verbose (full data) | cluster (grouped points) | '' (simplified)
 */
function layerGeoBB(options) {
	return layerVectorCluster(Object.assign({
		host: '//chemineur.fr/',
		urlFunction: function(options, bbox, selection) {
			return options.host + 'ext/Dominique92/GeoBB/gis.php?limit=10000' +
				'&layer=' + (options.subLayer || 'simple') +
				(options.selectorName ? '&' + (options.argSelName || 'cat') + '=' + selection.join(',') : '') +
				'&bbox=' + bbox.join(',');
		},
		convertProperties: function(properties, feature, options) {
			return {
				icon: properties.type ? options.host + 'ext/Dominique92/GeoBB/icones/' + properties.type + '.' + iconCanvasExt() : null,
				url: properties.id ? options.host + 'viewtopic.php?t=' + properties.id : null,
				attribution: options.attribution,
			};
		},
		styleOptionsFunction: function(feature, properties) {
			return Object.assign({},
				// Points
				styleOptionsIcon(properties.icon),
				// Polygons with color
				styleOptionsPolygon(properties.color, 0.5),
				// Lines
				{
					stroke: new ol.style.Stroke({
						color: 'blue',
						width: 2,
					}),
				}
			);
		},
		hoverStyleOptionsFunction: function(feature, properties) {
			return Object.assign({},
				styleOptionsFullLabel(properties), {
					// Lines
					stroke: new ol.style.Stroke({
						color: 'red',
						width: 3,
					}),
				}
			);
		},
	}, options));
}

/**
 * Site refuges.info
 */
function layerWri(options) {
	return layerVectorCluster(Object.assign({
		host: '//www.refuges.info/',
		urlFunction: function(options, bbox, selection) {
			return options.host + 'api/bbox?nb_points=all' +
				'&type_points=' + selection.join(',') +
				'&bbox=' + bbox.join(',');
		},
		convertProperties: function(properties, feature, options) {
			return {
				type: properties.type.valeur,
				name: properties.nom,
				icon: options.host + 'images/icones/' + properties.type.icone + '.' + iconCanvasExt(),
				ele: properties.coord.alt,
				capacity: properties.places.valeur,
				url: options.noClick ? null : properties.lien,
				attribution: 'Refuges.info'
			};
		},
		styleOptionsFunction: function(feature, properties) {
			return styleOptionsIcon(properties.icon);
		},
		hoverStyleOptionsFunction: function(feature, properties) {
			return styleOptionsFullLabel(properties);
		},
	}, options));
}

function layerWriAreas(options) {
	return layerVector(Object.assign({
		host: '//www.refuges.info/',
		polygon: 1, // Massifs
		urlFunction: function(options) {
			return options.host + 'api/polygones?type_polygon=' + options.polygon;
		},
		convertProperties: function(properties) {
			return {
				name: properties.nom,
				color: properties.couleur,
				url: properties.lien,
				attribution: null,
			};
		},
		styleOptionsFunction: function(feature, properties) {
			return Object.assign({},
				styleOptionsLabel(properties.name, properties),
				styleOptionsPolygon(properties.color, 0.5)
			);
		},
		hoverStyleOptionsFunction: function(feature, properties) {
			return Object.assign({},
				styleOptionsLabel(properties.name, properties, true),
				styleOptionsPolygon(properties.color, 1)
			);
		},
	}, options));
}

/**
 * Site pyrenees-refuges.com
 */
function layerPyreneesRefuges(options) {
	return layerVectorCluster(Object.assign({
		url: 'https://www.pyrenees-refuges.com/api.php?type_fichier=GEOJSON',
		strategy: ol.loadingstrategy.all,
		convertProperties: function(properties) {
			return {
				type: properties.type_hebergement,
				url: properties.url,
				ele: properties.altitude,
				capacity: properties.cap_ete,
				attribution: 'Pyrenees-Refuges',
			};
		},
		styleOptionsFunction: function(feature, properties) {
			return styleOptionsIconChemineur(properties.type_hebergement);
		},
		hoverStyleOptionsFunction: function(feature, properties) {
			return styleOptionsFullLabel(properties);
		},
	}, options));
}

/**
 * Site camptocamp.org
 */
function layerC2C(options) {
	const format = new ol.format.GeoJSON({ // Format of received data
		dataProjection: 'EPSG:3857',
	});

	format.readFeatures = function(json, opts) {
		const features = [],
			objects = JSONparse(json);

		for (let o in objects.documents) {
			const properties = objects.documents[o];

			features.push({
				id: properties.document_id,
				type: 'Feature',
				geometry: JSONparse(properties.geometry.geom),
				properties: {
					type: properties.waypoint_type,
					name: properties.locales[0].title,
					ele: properties.elevation,
					url: '//www.camptocamp.org/waypoints/' + properties.document_id,
					attribution: 'CampToCamp',
				},
			});
		}
		return format.readFeaturesFromObject({
				type: 'FeatureCollection',
				features: features,
			},
			format.getReadOptions(json, opts)
		);
	};

	return layerVectorCluster(Object.assign({
		urlFunction: function(options, bbox, selection, extent) {
			return 'https://api.camptocamp.org/waypoints?bbox=' + extent.join(',');
		},
		format: format,
		styleOptionsFunction: function(feature, properties) {
			return styleOptionsIconChemineur(properties.type);
		},
		hoverStyleOptionsFunction: function(feature, properties) {
			return styleOptionsFullLabel(properties);
		},
	}, options));
}

/**
 * OSM XML overpass POI layer
 * From: https://openlayers.org/en/latest/examples/vector-osm.html
 * Doc: http://wiki.openstreetmap.org/wiki/Overpass_API/Language_Guide
 */
function layerOverpass(options) {
	const format = new ol.format.OSMXML(),
		layer = layerVectorCluster(Object.assign({
			//host: 'overpass-api.de',
			//host: 'lz4.overpass-api.de',
			//host: 'overpass.openstreetmap.fr', // Out of order
			host: 'overpass.kumi.systems',
			//host: 'overpass.nchc.org.tw',

			urlFunction: urlFunction,
			maxResolution: 50,
			format: format,
			convertProperties: convertProperties,
			styleOptionsFunction: function(feature, properties) {
				return styleOptionsIconChemineur(properties.type);
			},
			hoverStyleOptionsFunction: function(feature, properties) {
				return styleOptionsFullLabel(properties);
			},
		}, options)),
		statusEl = document.getElementById(options.selectorName),
		selectorEls = document.getElementsByName(options.selectorName);

	// List of acceptable tags in the request return
	let tags = '';
	for (let e in selectorEls)
		tags += selectorEls[e].value;
	tags = tags.replace('private', '');

	function urlFunction(options, bbox, selection) {
		const bb = '(' + bbox[1] + ',' + bbox[0] + ',' + bbox[3] + ',' + bbox[2] + ');',
			args = [];

		// Convert selections on overpass_api language
		for (let l = 0; l < selection.length; l++) {
			const selections = selection[l].split('+');
			for (let ls = 0; ls < selections.length; ls++)
				args.push(
					'node' + selections[ls] + bb + // Ask for nodes in the bbox
					'way' + selections[ls] + bb // Also ask for areas
				);
		}

		return 'https://' + options.host + '/api/interpreter' +
			'?data=[timeout:5];(' + // Not too much !
			args.join('') +
			');out center;'; // Add center of areas
	}

	// Extract features from data when received
	format.readFeatures = function(doc, opt) {
		// Transform an area to a node (picto) at the center of this area
		for (let node = doc.documentElement.firstElementChild; node; node = node.nextSibling)
			if (node.nodeName == 'way') {
				// Create a new 'node' element centered on the surface
				const newNode = doc.createElement('node');
				newNode.id = node.id;
				doc.documentElement.appendChild(newNode);

				// Browse <way> attributes to build a new node
				for (let subTagNode = node.firstElementChild; subTagNode; subTagNode = subTagNode.nextSibling)
					switch (subTagNode.nodeName) {
						case 'center':
							// Set node attributes
							newNode.setAttribute('lon', subTagNode.getAttribute('lon'));
							newNode.setAttribute('lat', subTagNode.getAttribute('lat'));
							newNode.setAttribute('nodeName', subTagNode.nodeName);
							break;

						case 'tag': {
							// Get existing properties
							newNode.appendChild(subTagNode.cloneNode());

							// Add a tag to mem what node type it was (for link build)
							const newTag = doc.createElement('tag');
							newTag.setAttribute('k', 'nodetype');
							newTag.setAttribute('v', node.nodeName);
							newNode.appendChild(newTag);
						}
					}
			}
		// Status 200 / error message
		else if (node.nodeName == 'remark' && statusEl)
			statusEl.textContent = node.textContent;

		return ol.format.OSMXML.prototype.readFeatures.call(this, doc, opt);
	};

	function convertProperties(properties, feature) {
		for (let p in properties)
			if (tags.indexOf(p) !== -1 && tags.indexOf(properties[p]) !== -1)
				return {
					type: properties[p],
					name: properties.name || properties[p],
					ele: properties.ele,
					capacity: properties.capacity,
					url: 'https://www.openstreetmap.org/node/' + feature.getId(),
					attribution: 'osm',
				};
	}

	return layer;
}

/* FILE src/controls.js */
/**
 * Add some usefull controls
 * Need to include controls.css
 */

/**
 * Control button
 * Abstract definition to be used by other control buttons definitions
 */
function controlButton(options) {
	options = Object.assign({
		element: document.createElement('div'),
		buttonBackgroundColors: ['white', 'white'], // Also define the button states numbers
		className: 'ol-button',
		activate: function() {}, // Call back when the button is clicked. Argument = satus number (0, 1, ...)
	}, options);

	const control = new ol.control.Control(options),
		buttonEl = document.createElement('button');

	control.element.className = 'ol-button ol-unselectable ol-control ' + options.className;
	control.element.title = options.title; // {string} displayed when the control is hovered.
	if (options.label)
		buttonEl.innerHTML = options.label;
	if (options.label !== null)
		control.element.appendChild(buttonEl);

	buttonEl.addEventListener('click', function(evt) {
		evt.preventDefault();
		control.toggle();
	});

	// Add selectors below the button
	if (options.question) {
		control.questionEl = document.createElement('div');
		control.questionEl.innerHTML = options.question;
		control.questionEl.className = 'ol-control-hidden';

		control.element.appendChild(control.questionEl);
		control.element.onmouseover = function() {
			control.questionEl.className = 'ol-control-question';
		};
		control.element.onmouseout = function() {
			control.questionEl.className = 'ol-control-hidden';
		};
	}

	// Toggle the button status & aspect
	control.state = 0;

	control.toggle = function(newActive, group) {
		// Toggle by default
		if (newActive === undefined)
			newActive = control.state + 1;

		// Unselect all other controlButtons from the same group
		if (newActive && options.group)
			control.getMap().getControls().forEach(function(c) {
				if (c != control &&
					typeof c.toggle == 'function') // Only for controlButtons
					c.toggle(0, options.group);
			});

		// Execute the requested change
		if (control.state != newActive &&
			(!group || group == options.group)) { // Only for the concerned controls
			control.state = newActive % options.buttonBackgroundColors.length;
			buttonEl.style.backgroundColor = options.buttonBackgroundColors[control.state];
			options.activate(control.state);
		}
	};

	return control;
}

/**
 * Permalink control
 * "map" url hash or localStorage: zoom=<ZOOM> lon=<LON> lat=<LAT>
 * Don't set view when you declare the map
 */
function controlPermalink(options) {
	const aEl = document.createElement('a'),
		control = new ol.control.Control({
			element: document.createElement('div'),
			render: render,
		}),
		urlArgs = {
			map: '',
		};

	// Load url ?name=value&name=value and #name=value&name=value in urlArgs
	for (let v of location.href.replaceAll('NaN', '').matchAll(/([a-z]+)=([^?#&=]+)/g))
		urlArgs[v[1]] = v[2];

	options = Object.assign({
		init: true, // {true | false} use url hash or localStorage to position the map.
		setUrl: false, // {true | false} Change url hash when moving the map.
		display: false, // {true | false} Display permalink link the map.
		hash: '?', // {?, #} the permalink delimiter after the url
	}, options);

	if (options.display) {
		control.element.className = 'ol-permalink';
		aEl.innerHTML = 'Permalink';
		aEl.title = 'Generate a link with map zoom & position';
		control.element.appendChild(aEl);
	}

	function render(evt) {
		const view = evt.map.getView(),
			mapHash = (urlArgs.map + '//').split('/');

		// Set center & zoom at the init
		if (options.init) {
			options.init = false; // Only once

			view.setZoom(parseFloat(mapHash[0] || urlArgs.zoom || localStorage.myol_zoom.replace('NaN', '') || 6));

			view.setCenter(ol.proj.transform([
				parseFloat(mapHash[1] || urlArgs.lon || localStorage.myol_lon.replace('NaN', '') || 2),
				parseFloat(mapHash[2] || urlArgs.lat || localStorage.myol_lat.replace('NaN', '') || 47)
			], 'EPSG:4326', 'EPSG:3857'));
		}

		// Set the permalink with current map zoom & position
		if (view.getCenter()) {
			const ll4326 = ol.proj.transform(view.getCenter(), 'EPSG:3857', 'EPSG:4326'),
				newParams = 'map=' +
				(localStorage.myol_zoom = Math.round(view.getZoom() * 10) / 10) + '/' +
				(localStorage.myol_lon = Math.round(ll4326[0] * 10000) / 10000) + '/' +
				(localStorage.myol_lat = Math.round(ll4326[1] * 10000) / 10000);

			if (options.display)
				aEl.href = options.hash + newParams;

			if (options.setUrl)
				location.href = '#' + newParams;
		}
	}
	return control;
}

/**
 * Control to display the mouse position
 */
function controlMousePosition() {
	return new ol.control.MousePosition({
		projection: 'EPSG:4326',
		className: 'ol-coordinate',
		undefinedHTML: String.fromCharCode(0),

		coordinateFormat: function(mouse) {
			if (ol.gpsPosition) {
				const ll4326 = ol.proj.transform(ol.gpsPosition, 'EPSG:3857', 'EPSG:4326'),
					distance = ol.sphere.getDistance(mouse, ll4326);

				return distance < 1000 ?
					(Math.round(distance)) + ' m' :
					(Math.round(distance / 10) / 100) + ' km';
			} else
				return ol.coordinate.createStringXY(4)(mouse);
		},
	});
}

/**
 * Control to display the length of an hovered line
 * option hoverStyle style the hovered feature
 */
function controlLengthLine() {
	const control = new ol.control.Control({
		element: document.createElement('div'), // div to display the measure
	});
	control.element.className = 'ol-length-line';

	control.setMap = function(map) {
		ol.control.Control.prototype.setMap.call(this, map);

		map.on('pointermove', function(evt) {
			control.element.innerHTML = ''; // Clear the measure if hover no feature

			// Find new features to hover
			map.forEachFeatureAtPixel(evt.pixel, calculateLength, {
				hitTolerance: 6, // Default is 0
			});
		});
	};

	function calculateLength(feature) {
		// Display the line length
		if (feature) {
			const length = ol.sphere.getLength(feature.getGeometry());

			control.element.innerHTML = length < 1000 ?
				(Math.round(length)) + ' m' :
				(Math.round(length / 10) / 100) + ' km';
		}
		return false; // Continue detection (for editor that has temporary layers)
	}
	return control;
}

/**
 * Control to display set preload of depth upper level tiles
 * This prepares the browser to become offline
 */
function controlTilesBuffer(depth) {
	const control = new ol.control.Control({
		element: document.createElement('div'),
	});

	control.setMap = function(map) {
		ol.control.Control.prototype.setMap.call(this, map);

		// Action on each layer
		map.on('precompose', function() {
			map.getLayers().forEach(function(layer) {
				if (typeof layer.setPreload == 'function')
					layer.setPreload(depth);
			});
		});
	};

	return control;
}

/**
 * Geocoder
 * Requires https://github.com/jonataswalker/ol-geocoder/tree/master/dist
 */
function controlGeocoder(options) {
	options = Object.assign({
		title: 'Recherche sur la carte',
	}, options);

	if (typeof Geocoder != 'function') // Vérify if geocoder is available
		return new ol.control.Control({
			element: document.createElement('div'),
		});

	const geocoder = new Geocoder('nominatim', {
		provider: 'osm',
		lang: 'fr-FR',
		autoComplete: false, // Else keep list of many others
		keepOpen: true, // Else bug "no internet"
		placeholder: options.title, // Initialization of the input field
	});

	// Move the button at the same level than the other control's buttons
	const buttonEl = geocoder.element.firstElementChild.firstElementChild;
	buttonEl.innerHTML = '&#x1F50D;';
	buttonEl.title = options.title;
	geocoder.element.appendChild(buttonEl);

	return geocoder;
}

/**
 * GPS control
 * Requires controlButton
 */
function controlGPS() {
	let view, geolocation, nbLoc, position, heading, accuracy, altitude, speed;

	// Display status, altitude & speed
	const displayEl = document.createElement('div'),

		control = controlButton({
			className: 'ol-button ol-gps',
			label: '&#x2295;',
			buttonBackgroundColors: [ // Define 4 states button
				'white', // 0 : inactive
				'orange', // 1 : waiting physical GPS sensor position & altitude
				'lime', // 2 : active, centered & oriented
				'grey', // 3 : active, do not centered nor oriented
			],
			title: 'Centrer sur la position GPS',
			activate: function(state) {
				if (geolocation) {
					geolocation.setTracking(state !== 0);
					graticuleLayer.setVisible(state !== 0);
					nbLoc = 0;
					if (!state && view) {
						view.setRotation(0, 0); // Set north to top
						displayEl.innerHTML = '';
						displayEl.classList.remove('ol-control-gps');
					}
				}
				ol.gpsPosition = null;
			}
		}),

		// Graticule
		graticuleFeature = new ol.Feature(),
		northGraticuleFeature = new ol.Feature(),
		graticuleLayer = new ol.layer.Vector({
			source: new ol.source.Vector({
				features: [graticuleFeature, northGraticuleFeature],
			}),
			zIndex: 20, // Above the features
			style: new ol.style.Style({
				fill: new ol.style.Fill({
					color: 'rgba(128,128,255,0.2)',
				}),
				stroke: new ol.style.Stroke({
					color: '#20b',
					lineDash: [16, 14],
					width: 1,
				}),
			}),
		});

	control.element.appendChild(displayEl);

	graticuleFeature.setStyle(new ol.style.Style({
		stroke: new ol.style.Stroke({
			color: '#000',
			lineDash: [16, 14],
			width: 1,
		}),
	}));

	northGraticuleFeature.setStyle(new ol.style.Style({
		stroke: new ol.style.Stroke({
			color: '#c00',
			lineDash: [16, 14],
			width: 1,
		}),
	}));

	control.setMap = function(map) {
		ol.control.Control.prototype.setMap.call(this, map);

		view = map.getView();
		map.addLayer(graticuleLayer);

		geolocation = new ol.Geolocation({
			projection: view.getProjection(),
			trackingOptions: {
				enableHighAccuracy: true,
				maximumAge: 1000,
				timeout: 1000,
			},
		});

		// Trigger position
		geolocation.on('change:position', renderPosition);
		map.on('moveend', renderPosition); // Refresh graticule after map zoom
		function renderPosition() {
			position = geolocation.getPosition();
			accuracy = geolocation.getAccuracyGeometry();
			renderGPS();
		}

		// Triggers data display
		geolocation.on(['change:altitude', 'change:speed', 'change:tracking'], function() {
			speed = Math.round(geolocation.getSpeed() * 36) / 10;
			altitude = geolocation.getAltitude();
			renderGPS();
		});

		// Browser heading from the inertial & magnetic sensors
		window.addEventListener('deviceorientationabsolute', function(evt) {
			if (evt.absolute) { // Breaks support for non-absolute browsers, like firefox mobile
				heading = evt.alpha || evt.webkitCompassHeading; // Android || iOS
				renderGPS();
			}
		});

		geolocation.on('error', function(error) {
			alert('Geolocation error: ' + error.message);
		});
	};

	function renderGPS() {
		// Display data under the button
		let displays = [];

		if (control.state) {
			if (altitude)
				displays.push(Math.round(altitude) + ' m');

			if (!isNaN(speed))
				displays.push(speed + ' km/h');

			if (altitude === undefined)
				displays = ['GPS sync...'];
			else if (control.state == 1)
				control.toggle(); // Go directly to state 2
		}

		displayEl.innerHTML = displays.join(', ');
		displayEl.classList[displays.length ? 'add' : 'remove']('ol-control-gps');

		// Render position & graticule
		if (control.state && position &&
			(control.state > 1 || altitude !== undefined)) { // Position on GPS signal only on state 1
			const map = control.getMap(),
				// Estimate the viewport size to draw visible graticule
				hg = map.getCoordinateFromPixel([0, 0]),
				bd = map.getCoordinateFromPixel(map.getSize()),
				far = Math.hypot(hg[0] - bd[0], hg[1] - bd[1]) * 10,

				// The graticule
				geometry = [
					new ol.geom.MultiLineString([
						[
							[position[0] - far, position[1]],
							[position[0] + far, position[1]]
						],
						[
							[position[0], position[1]],
							[position[0], position[1] - far]
						],
					]),
				],

				// Color north in red
				northGeometry = [
					new ol.geom.LineString([
						[position[0], position[1]],
						[position[0], position[1] + far]
					]),
				];

			graticuleFeature.setGeometry(new ol.geom.GeometryCollection(geometry));
			northGraticuleFeature.setGeometry(new ol.geom.GeometryCollection(northGeometry));

			// The accuracy circle
			const accuracy = geolocation.getAccuracyGeometry();
			if (accuracy)
				geometry.push(accuracy);

			if (control.state == 2) {
				// Center the map
				view.setCenter(position);

				if (!nbLoc) { // Only the first time after activation
					view.setZoom(17); // Zoom on the area

					map.dispatchEvent({
						type: 'myol:ongpsactivate',
					});
				}

				nbLoc++;

				// Orientation
				if (heading)
					view.setRotation(
						Math.PI / 180 * (heading - screen.orientation.angle), // Delivered ° reverse clockwize
						0
					);
			}

			// For other controls usage
			ol.gpsPosition = position;
		}
	}

	return control;
}

/**
 * GPX file loader control
 * Requires controlButton
 */
function controlLoadGPX(options) {
	options = Object.assign({
		label: '&#x1F4C2;',
		title: 'Visualiser un fichier GPX sur la carte',
		activate: function() {
			inputEl.click();
		},
	}, options);

	const inputEl = document.createElement('input'),
		format = new ol.format.GPX(),
		reader = new FileReader(),
		control = controlButton(options);

	inputEl.type = 'file';
	inputEl.addEventListener('change', function() {
		if (inputEl.files)
			reader.readAsText(inputEl.files[0]);
	});

	reader.onload = function() {
		const map = control.getMap(),
			features = format.readFeatures(reader.result, {
				dataProjection: 'EPSG:4326',
				featureProjection: 'EPSG:3857',
			}),
			added = map.dispatchEvent({
				type: 'myol:onfeatureload', // Warn layerEditGeoJson that we uploaded some features
				features: features,
			});

		if (added !== false) { // If one used the feature
			// Display the track on the map
			const source = new ol.source.Vector({
					format: format,
					features: features,
				}),
				layer = new ol.layer.Vector({
					source: source,
					style: function(feature) {
						const properties = feature.getProperties(),
							styleOptions = {
								stroke: new ol.style.Stroke({
									color: 'blue',
									width: 3,
								}),
							};

						if (properties.sym)
							styleOptions.image = new ol.style.Icon({
								src: '//chemineur.fr/ext/Dominique92/GeoBB/icones/' + properties.sym + '.svg',
							});

						return new ol.style.Style(styleOptions);
					},
				});
			map.addLayer(layer);
		}

		// Zoom the map on the added features
		const extent = ol.extent.createEmpty();
		for (let f in features)
			ol.extent.extend(extent, features[f].getGeometry().getExtent());
		if (ol.extent.isEmpty(extent))
			alert('Fichier GPX vide');
		else
			map.getView().fit(extent, {
				maxZoom: 17,
				size: map.getSize(),
				padding: [5, 5, 5, 5],
			});
	};
	return control;
}

/**
 * File downloader control
 * Requires controlButton
 */
function controlDownload(options) {
	options = Object.assign({
		label: '&#x1F4E5;',
		buttonBackgroundColors: ['white'],
		className: 'ol-button ol-download',
		title: 'Cliquer sur un format ci-dessous\n' +
			'pour obtenir un fichier contenant\n' +
			'les éléments visibles dans la fenêtre.\n' +
			'(la liste peut être incomplète pour les grandes zones)',
		question: '<span/>', // Invisible but generates a questionEl <div>
		fileName: document.title || 'openlayers',
		activate: download,
	}, options);

	const hiddenEl = document.createElement('a'),
		control = controlButton(options);
	hiddenEl.target = '_self';
	hiddenEl.style = 'display:none';
	document.body.appendChild(hiddenEl);

	const formats = {
		GPX: 'application/gpx+xml',
		KML: 'vnd.google-earth.kml+xml',
		GeoJSON: 'application/json',
	};
	for (let f in formats) {
		const el = document.createElement('p');
		el.onclick = download;
		el.innerHTML = f;
		el.id = formats[f];
		el.title = 'Obtenir un fichier ' + f;
		control.questionEl.appendChild(el);
	}

	function download() { //formatName, mime
		const formatName = this.textContent || 'GPX',
			mime = this.id,
			format = new ol.format[formatName](),
			map = control.getMap();
		let features = [],
			extent = map.getView().calculateExtent();

		// Get all visible features
		if (options.savedLayer)
			getFeatures(options.savedLayer);
		else
			map.getLayers().forEach(getFeatures);

		function getFeatures(layer) {
			if (layer.getSource() && layer.getSource().forEachFeatureInExtent) // For vector layers only
				layer.getSource().forEachFeatureInExtent(extent, function(feature) {
					if (!layer.marker_)
						features.push(feature);
				});
		}

		const data = format.writeFeatures(features, {
				dataProjection: 'EPSG:4326',
				featureProjection: 'EPSG:3857',
				decimals: 5,
			})
			// Beautify the output
			.replace(/<[a-z]*>(0|null|[\[object Object\]|[NTZa:-]*)<\/[a-z]*>/g, '')
			.replace(/<Data name="[a-z_]*"\/>|<Data name="[a-z_]*"><\/Data>|,"[a-z_]*":""/g, '')
			.replace(/<Data name="copy"><value>[a-z_\.]*<\/value><\/Data>|,"copy":"[a-z_\.]*"/g, '')
			.replace(/(<\/gpx|<\/?wpt|<\/?trk>|<\/?rte>|<\/kml|<\/?Document)/g, '\n$1')
			.replace(/(<\/?Placemark|POINT|LINESTRING|POLYGON|<Point|"[a-z_]*":|})/g, '\n$1')
			.replace(/(<name|<ele|<sym|<link|<type|<rtept|<\/?trkseg|<\/?ExtendedData)/g, '\n\t$1')
			.replace(/(<trkpt|<Data|<LineString|<\/?Polygon|<Style)/g, '\n\t\t$1')
			.replace(/(<[a-z]+BoundaryIs)/g, '\n\t\t\t$1'),

			file = new Blob([data], {
				type: mime,
			});

		hiddenEl.download = options.fileName + '.' + formatName.toLowerCase();
		hiddenEl.href = URL.createObjectURL(file);
		hiddenEl.click();
	}
	return control;
}

/**
 * Print control
 * Requires controlButton
 */
function controlPrint() {
	const control = controlButton({
		className: 'ol-button ol-print',
		title: 'Pour imprimer la carte:\n' +
			'choisir l‘orientation,\n' +
			'zoomer et déplacer,\n' +
			'cliquer sur l‘icône imprimante.',
		question: '<input type="radio" name="print-orientation" id="ol-po0" value="0" />' +
			'<label for="ol-po0">Portrait A4</label><br />' +
			'<input type="radio" name="print-orientation" id="ol-po1" value="1" />' +
			'<label for="ol-po1">Paysage A4</label>',
		activate: function() {
			resizeDraft(control.getMap());
			control.getMap().once('rendercomplete', function() {
				window.print();
				location.reload();
			});
		},
	});

	control.setMap = function(map) {
		ol.control.Control.prototype.setMap.call(this, map);

		const poEls = document.getElementsByName('print-orientation');

		for (let i in poEls)
			poEls[i].onchange = resizeDraft;
	};

	function resizeDraft() {
		const map = control.getMap(),
			mapEl = map.getTargetElement(),
			poElcs = document.querySelectorAll('input[name=print-orientation]:checked'),
			orientation = poElcs.length ? parseInt(poElcs[0].value) : 0;

		mapEl.style.maxHeight = mapEl.style.maxWidth =
			mapEl.style.float = 'none';
		mapEl.style.width = orientation == 0 ? '208mm' : '295mm';
		mapEl.style.height = orientation == 0 ? '295mm' : '208mm';
		map.setSize([mapEl.clientWidth, mapEl.clientHeight]);

		// Set portrait / landscape
		const styleSheet = document.createElement('style');
		styleSheet.type = 'text/css';
		styleSheet.innerText = '@page {size: ' + (orientation == 0 ? 'portrait' : 'landscape') + '}';
		document.head.appendChild(styleSheet);

		// Hide all but the map
		document.body.appendChild(mapEl);
		for (let child = document.body.firstElementChild; child !== null; child = child.nextSibling)
			if (child.style && child !== mapEl)
				child.style.display = 'none';

		// Finer zoom not dependent on the baselayer's levels
		map.getView().setConstrainResolution(false);
		map.addInteraction(new ol.interaction.MouseWheelZoom({
			maxDelta: 0.1,
		}));

		// To return without print
		document.addEventListener('keydown', function(evt) {
			if (evt.key == 'Escape')
				setTimeout(function() { // Delay reload for FF & Opera
					location.reload();
				});
		});
	}

	return control;
}

/**
 * Controls examples
 */
function controlsCollection(options) {
	options = options || {};

	return [
		// Top left
		new ol.control.Zoom(),
		new ol.control.FullScreen(),
		controlGeocoder(),
		controlGPS(options.controlGPS),
		controlLoadGPX(),
		controlDownload(options.controlDownload),
		controlPrint(),

		// Bottom left
		controlLengthLine(),
		controlMousePosition(),
		new ol.control.ScaleLine(),

		// Bottom right
		controlPermalink(options.permalink),
		new ol.control.Attribution(),
	];
}

/* FILE src/marker.js */
/**
 * Marker position display & edit
 * Requires myol:onadd
 * Options:
 *   src : url of the marker image
 *   prefix : id prefix of input/output values
 *   focus : center & zoom on the marker
 *   dragable : can draw the marker to edit position
 */
function layerMarker(options) {
	const els = [],
		point = new ol.geom.Point([0, 0]),
		layer = new ol.layer.Vector(Object.assign({
			source: new ol.source.Vector({
				features: [new ol.Feature(point)],
			}),
			zIndex: 1,
			style: new ol.style.Style({
				image: new ol.style.Icon({
					anchor: [0.5, 0.5],
					src: options.src,
				}),
			}),
		}, options));

	// Initialise specific projection
	if (typeof proj4 == 'function') {
		// Swiss
		proj4.defs('EPSG:21781', '+proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=600000 +y_0=200000 +ellps=bessel +towgs84=660.077,13.551,369.344,2.484,1.783,2.939,5.66 +units=m +no_defs');

		// UTM zones
		for (let u = 1; u <= 60; u++) {
			proj4.defs('EPSG:' + (32600 + u), '+proj=utm +zone=' + u + ' +ellps=WGS84 +datum=WGS84 +units=m +no_defs');
			proj4.defs('EPSG:' + (32700 + u), '+proj=utm +zone=' + u + ' +ellps=WGS84 +datum=WGS84 +units=m +no_defs');
		}

		ol.proj.proj4.register(proj4);
	}

	// Collect all entries elements
	['json', 'lon', 'lat', 'x', 'y', 'coordinates', 'select', 'string'].forEach(i => {
		els[i] = document.getElementById((options.prefix || 'marker') + '-' + i) || document.createElement('div');
		els[i].onchange = onChange;
	});

	// Initialise position with existing entries values
	els.lon.onchange();
	els.json.onchange();

	// Read new values
	function onChange() {
		const fieldName = this.id.match(/-([a-z])/);

		if (fieldName) {
			if (fieldName[1] == 'j') { // json
				const json = (els.json.value).match(/([-0-9\.]+)[, ]*([-0-9\.]+)/);

				if (json)
					changeLL(json.slice(1), 'EPSG:4326', true);
			} else
			if (fieldName[1] == 'l') // lon | lat
				changeLL([els.lon.value, els.lat.value], 'EPSG:4326', true);
			else
			if (typeof proj4 == 'function') // x | y
				changeLL([parseInt(els.x.value), parseInt(els.y.value)], 'EPSG:21781', true);
		}
	}

	// Display values
	function changeLL(ll, projection, focus) {
		if (ll[0] && ll[1]) {
			// Wrap +-180°
			const bounds = ol.proj.transform([180, 85], 'EPSG:4326', projection);

			ll[0] -= Math.round(ll[0] / bounds[0] / 2) * bounds[0] * 2;

			const ll3857 = ol.proj.transform(ll, projection, 'EPSG:3857'),
				ll4326 = ol.proj.transform(ll, projection, 'EPSG:4326');

			// Move the marker
			point.setCoordinates(ll3857);

			// Move the map
			if (focus && layer.map_)
				layer.map_.getView().setCenter(ll3857);

			// Populate inputs
			els.lon.value = Math.round(ll4326[0] * 100000) / 100000;
			els.lat.value = Math.round(ll4326[1] * 100000) / 100000;
			els.json.value = '{"type":"Point","coordinates":[' + els.lon.value + ',' + els.lat.value + ']}';

			// Display
			const strings = {
				dec: 'Lon: ' + els.lon.value + ', Lat: ' + els.lat.value,
				dms: ol.coordinate.toStringHDMS(ll4326),
			};

			if (typeof proj4 == 'function') {
				// UTM zones
				const z = Math.floor(ll4326[0] / 6 + 90) % 60 + 1,
					u = 32600 + z + (ll4326[1] < 0 ? 100 : 0),
					llutm = ol.proj.transform(ll, projection, 'EPSG:' + u);

				// Swiss
				const ll21781 = ol.proj.transform(ll, projection, 'EPSG:21781');
				els.x.value = Math.round(ll21781[0]);
				els.y.value = Math.round(ll21781[1]);

				// Display
				strings.swiss = 'X=' + els.x.value + ', Y=' + els.y.value + ' (CH1903)';
				strings.utm = ' UTM ' + z +
					' E:' + Math.round(llutm[0]) + ' ' +
					(llutm[1] > 0 ? 'N:' : 'S:') + Math.round(llutm[1] + (llutm[1] > 0 ? 0 : 10000000));

				// Hide Swiss coordinates when out of extent
				const epsg21781 = ol.extent.containsCoordinate([664577, 5753148, 1167741, 6075303], ll3857);

				els.coordinates.classList[epsg21781 ? 'add' : 'remove']('epsg21781');

				if (!epsg21781 && els.select.value == 'swiss')
					els.select.value = 'dec';
			}

			// Display selected format
			els.string.textContent = strings[els.select.value || 'dec'];
		}
	}

	layer.once('myol:onadd', function(evt) {
		const map = evt.map,
			view = map.getView(),
			pc = point.getCoordinates();

		// Focus map on the marker
		if (options.focus) {
			if (pc[0] && pc[1])
				view.setCenter(pc);
			else
				// If no position given, put the marker on the center of the visible map
				changeLL(view.getCenter(), 'EPSG:3857');

			view.setZoom(options.focus);
		}

		// Edit the marker position
		if (options.dragable) {
			// Drag the marker
			map.addInteraction(new ol.interaction.Pointer({
				handleDownEvent: function(evt) {
					return map.getFeaturesAtPixel(evt.pixel, {
						layerFilter: function(l) {
							return l.ol_uid == layer.ol_uid;
						}
					}).length;
				},
				handleDragEvent: function(evt) {
					changeLL(evt.coordinate, 'EPSG:3857');
				},
			}));

			// Get the marker at the dblclick position
			map.on('dblclick', function(evt) {
				changeLL(evt.coordinate, 'EPSG:3857');
				return false;
			});
		}
	});

	return layer;
}

/* FILE src/editor.js */
/**
 * geoJson lines & polygons display
 * Lines & polygons edit
 * Requires JSONparse, myol:onadd, controlButton (from src/controls.js file)
 */
function layerEditGeoJson(options) {
	options = Object.assign({
		format: new ol.format.GeoJSON(),
		projection: 'EPSG:3857',
		geoJsonId: 'editable-json', // Option geoJsonId : html element id of the geoJson features to be edited
		focus: false, // Zoom the map on the loaded features
		snapLayers: [], // Vector layers to snap on
		readFeatures: function() {
			return options.format.readFeatures(
				options.geoJson ||
				JSONparse(geoJsonValue || '{"type":"FeatureCollection","features":[]}'), {
					featureProjection: options.projection,
				});
		},
		saveFeatures: function(coordinates, format) {
			return format.writeFeatures(
					source.getFeatures(
						coordinates, format), {
						featureProjection: options.projection,
						decimals: 5,
					})
				.replace(/"properties":\{[^\}]*\}/, '"properties":null');
		},
		// Drag lines or Polygons
		styleOptions: {
			// Marker circle
			image: new ol.style.Circle({
				radius: 4,
				stroke: new ol.style.Stroke({
					color: 'red',
					width: 2,
				}),
			}),
			// Editable lines or polygons border
			stroke: new ol.style.Stroke({
				color: 'red',
				width: 2,
			}),
			// Editable polygons
			fill: new ol.style.Fill({
				color: 'rgba(0,0,255,0.2)',
			}),
		},
		editStyleOptions: { // Hover / modify / create
			// Editable lines or polygons border
			stroke: new ol.style.Stroke({
				color: 'red',
				width: 4,
			}),
			// Editable polygons fill
			fill: new ol.style.Fill({
				color: 'rgba(255,0,0,0.3)',
			}),
		},
	}, options);

	const geoJsonEl = document.getElementById(options.geoJsonId), // Read data in an html element
		geoJsonValue = geoJsonEl ? geoJsonEl.value : '',
		style = escapedStyle(options.styleOptions),
		editStyle = escapedStyle(options.styleOptions, options.editStyleOptions),

		features = options.readFeatures(),
		source = new ol.source.Vector({
			features: features,
			wrapX: false,
		}),
		layer = new ol.layer.Vector({
			source: source,
			zIndex: 20, // Editor & cursor : above the features
			style: style,
		}),
		snap = new ol.interaction.Snap({
			source: source,
			pixelTolerance: 7.5, // 6 + line width / 2 : default is 10
		}),
		modify = new ol.interaction.Modify({
			source: source,
			pixelTolerance: 16, // Default is 10
			style: editStyle,
		}),
		controlModify = controlButton({
			group: 'edit',
			label: options.titleModify ? 'M' : null,
			buttonBackgroundColors: ['white', '#ef3'],
			title: options.titleModify,
			activate: function(state) {
				activate(state, modify);
			},
		});

	// Snap on vector layers
	options.snapLayers.forEach(function(layer) {
		layer.getSource().on('change', function() {
			const fs = layer.getSource().getFeatures();
			for (let f in fs)
				snap.addFeature(fs[f]);
		});
	});

	// Manage hover to save modify actions integrity
	let hoveredFeature = null;

	layer.once('myol:onadd', function(evt) {
		const map = evt.map,
			extent = ol.extent.createEmpty(); // For focus on all features calculation

		optimiseEdited(); // Treat the geoJson input as any other edit

		// Add required controls
		if (options.titleModify) {
			map.addControl(controlModify);
			controlModify.toggle(true);
		}
		if (options.titleLine)
			map.addControl(controlDraw({
				type: 'LineString',
				label: 'L',
				title: options.titleLine,
			}));
		if (options.titlePolygon)
			map.addControl(controlDraw({
				type: 'Polygon',
				label: 'P',
				title: options.titlePolygon,
			}));

		// Zoom the map on the loaded features
		if (options.focus && features.length) {
			for (let f in features)
				ol.extent.extend(extent, features[f].getGeometry().getExtent());
			map.getView().fit(extent, {
				maxZoom: options.focus,
				size: map.getSize(),
				padding: [5, 5, 5, 5],
			});
		}

		// Add features loaded from GPX file
		map.on('myol:onfeatureload', function(evt) {
			source.addFeatures(evt.features);
			optimiseEdited();
			return false; // Warn controlLoadGPX that the editor got the included feature
		});

		map.on('pointermove', hover);
	});


	modify.on('modifyend', function(evt) {

		// Ctrl+Alt+click on segment : delete the line or poly
		if (evt.mapBrowserEvent.originalEvent.ctrlKey &&
			evt.mapBrowserEvent.originalEvent.altKey) {
			const selectedFeatures = layer.map_.getFeaturesAtPixel(
				evt.mapBrowserEvent.pixel, {
					hitTolerance: 6, // Default is 0
					layerFilter: function(l) {
						return l.ol_uid == layer.ol_uid;
					}
				});

			for (let f in selectedFeatures) // We delete the selected feature
				source.removeFeature(selectedFeatures[f]);
		}

		// Alt+click on segment : delete the segment & split the line
		const newFeature = snap.snapTo(
			evt.mapBrowserEvent.pixel,
			evt.mapBrowserEvent.coordinate,
			snap.getMap()
		);

		if (evt.mapBrowserEvent.originalEvent.altKey && newFeature)
			optimiseEdited(newFeature.vertex);

		// Finish
		optimiseEdited();
		hoveredFeature = null; // Recover hovering
	});

	// End of feature creation
	source.on('change', function() { // Called all sliding long
		if (source.modified) { // Awaiting adding complete to save it
			source.modified = false; // To avoid loops

			// Finish
			optimiseEdited();
			hoveredFeature = null; // Recover hovering
		}
	});

	function activate(state, inter) { // Callback at activation / desactivation, mandatory, no default
		if (state) {
			layer.map_.addInteraction(inter);
			layer.map_.addInteraction(snap); // Must be added after
		} else {
			layer.map_.removeInteraction(snap);
			layer.map_.removeInteraction(inter);
		}
	}

	function controlDraw(options) {
		const control = controlButton(Object.assign({
				group: 'edit',
				buttonBackgroundColors: ['white', '#ef3'],
				activate: function(state) {
					activate(state, interaction);
				},
			}, options)),
			interaction = new ol.interaction.Draw(Object.assign({
				style: editStyle,
				source: source,
				stopClick: true, // Avoid zoom when you finish drawing by doubleclick
			}, options));

		interaction.on(['drawend'], function() {
			// Switch on the main editor button
			controlModify.toggle(true);

			// Warn source 'on change' to save the feature
			// Don't do it now as it's not yet added to the source
			source.modified = true;
		});
		return control;
	}

	function hover(evt) {
		let nbFeaturesAtPixel = 0;
		layer.map_.forEachFeatureAtPixel(evt.pixel, function(feature) {
			source.getFeatures().forEach(function(f) {
				if (f.ol_uid == feature.ol_uid) {
					nbFeaturesAtPixel++;
					if (!hoveredFeature) { // Hovering only one
						feature.setStyle(editStyle);
						hoveredFeature = feature; // Don't change it until there is no more hovered
					}
				}
			});
		}, {
			hitTolerance: 6, // Default is 0
		});

		// If no more hovered, return to the normal style
		if (!nbFeaturesAtPixel && !evt.originalEvent.buttons && hoveredFeature) {
			hoveredFeature.setStyle(style);
			hoveredFeature = null;
		}
	}

	function escapedStyle(a, b, c) {
		const defaultStyle = new ol.layer.Vector().getStyleFunction()()[0];
		return function(feature) {
			return new ol.style.Style(Object.assign({
					fill: defaultStyle.getFill(),
					stroke: defaultStyle.getStroke(),
					image: defaultStyle.getImage(),
				},
				typeof a == 'function' ? a(feature.getProperties()) : a,
				typeof b == 'function' ? b(feature.getProperties()) : b,
				typeof c == 'function' ? c(feature.getProperties()) : c
			));
		};
	}

	function optimiseEdited(deleteCoords) {
		const coordinates = optimiseFeatures(
			source.getFeatures(),
			options.titleLine,
			options.titlePolygon,
			true,
			true,
			deleteCoords
		);

		// Recreate features
		source.clear();
		for (let l in coordinates.lines)
			source.addFeature(new ol.Feature({
				geometry: new ol.geom.LineString(coordinates.lines[l]),
			}));
		for (let p in coordinates.polys)
			source.addFeature(new ol.Feature({
				geometry: new ol.geom.Polygon(coordinates.polys[p]),
			}));

		// Save geometries in <EL> as geoJSON at every change
		if (geoJsonEl)
			geoJsonEl.value = options.saveFeatures(coordinates, options.format);
	}

	return layer;
}

/**
 * Refurbish Lines & Polygons
 * Split lines having a summit at deleteCoords
 * Common to controlDownload & layerEditGeoJson
 */
function optimiseFeatures(features, withLines, withPolygons, merge, holes, deleteCoords) {
	const points = [],
		lines = [],
		polys = [];

	// Get all edited features as array of coordinates
	for (let f in features)
		flatFeatures(features[f].getGeometry(), points, lines, polys, deleteCoords);

	for (let a in lines)
		// Exclude 1 coordinate features (points)
		if (lines[a].length < 2)
			delete lines[a];

		// Merge lines having a common end
		else if (merge)
		for (let b = 0; b < a; b++) // Once each combination
			if (lines[b]) {
				const m = [a, b];
				for (let i = 4; i; i--) // 4 times
					if (lines[m[0]] && lines[m[1]]) { // Test if the line has been removed
						// Shake lines end to explore all possibilities
						m.reverse();
						lines[m[0]].reverse();
						if (compareCoords(lines[m[0]][lines[m[0]].length - 1], lines[m[1]][0])) {
							// Merge 2 lines having 2 ends in common
							lines[m[0]] = lines[m[0]].concat(lines[m[1]].slice(1));
							delete lines[m[1]]; // Remove the line but don't renumber the array keys
						}
					}
			}

	// Make polygons with looped lines
	for (let a in lines)
		if (withPolygons && // Only if polygons are autorized
			lines[a]) {
			// Close open lines
			if (!withLines) // If only polygons are autorized
				if (!compareCoords(lines[a]))
					lines[a].push(lines[a][0]);

			if (compareCoords(lines[a])) { // If this line is closed
				// Split squeezed polygons
				// Explore all summits combinaison
				for (let i1 = 0; i1 < lines[a].length - 1; i1++)
					for (let i2 = 0; i2 < i1; i2++)
						if (lines[a][i1][0] == lines[a][i2][0] &&
							lines[a][i1][1] == lines[a][i2][1]) { // Find 2 identical summits
							let squized = lines[a].splice(i2, i1 - i2); // Extract the squized part
							squized.push(squized[0]); // Close the poly
							polys.push([squized]); // Add the squized poly
							i1 = i2 = lines[a].length; // End loop
						}

				// Convert closed lines into polygons
				polys.push([lines[a]]); // Add the polygon
				delete lines[a]; // Forget the line
			}
		}

	// Makes holes if a polygon is included in a biggest one
	for (let p1 in polys) // Explore all Polygons combinaison
		if (holes && // Make holes option
			polys[p1]) {
			const fs = new ol.geom.Polygon(polys[p1]);
			for (let p2 in polys)
				if (polys[p2] && p1 != p2) {
					let intersects = true;
					for (let c in polys[p2][0])
						if (!fs.intersectsCoordinate(polys[p2][0][c]))
							intersects = false;
					if (intersects) { // If one intersects a bigger
						polys[p1].push(polys[p2][0]); // Include the smaler in the bigger
						delete polys[p2]; // Forget the smaller
					}
				}
		}

	return {
		points: points,
		lines: lines.filter(Boolean), // Remove deleted array members
		polys: polys.filter(Boolean),
	};

	function flatFeatures(geom, points, lines, polys, deleteCoords) {
		// Expand geometryCollection
		if (geom.getType() == 'GeometryCollection') {
			const geometries = geom.getGeometries();
			for (let g in geometries)
				flatFeatures(geometries[g], points, lines, polys, deleteCoords);
		}
		// Point
		else if (geom.getType().match(/point$/i))
			points.push(geom.getCoordinates());

		// line & poly
		else
			flatCoord(lines, geom.getCoordinates(), deleteCoords); // Get lines or polyons as flat array of coordinates
	}

	// Get all lines fragments (lines, polylines, polygons, multipolygons, hole polygons, ...)
	// at the same level & split if one point = deleteCoords
	function flatCoord(existingCoords, newCoords, deleteCoords) {
		if (typeof newCoords[0][0] == 'object') // Multi*
			for (let c1 in newCoords)
				flatCoord(existingCoords, newCoords[c1], deleteCoords);
		else {
			existingCoords.push([]); // Add a new segment

			for (let c2 in newCoords)
				if (deleteCoords && compareCoords(newCoords[c2], deleteCoords))
					existingCoords.push([]); // Ignore this point and add a new segment
				else
					// Stack on the last existingCoords array
					existingCoords[existingCoords.length - 1].push(newCoords[c2]);
		}
	}

	function compareCoords(a, b) {
		if (!a)
			return false;
		if (!b)
			return compareCoords(a[0], a[a.length - 1]); // Compare start with end
		return a[0] == b[0] && a[1] == b[1]; // 2 coordinates
	}
}