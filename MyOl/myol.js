/** OPENLAYERS ADAPTATION
 * © Dominique Cavailhez 2017
 * https://github.com/Dominique92/MyOl
 * Based on https://openlayers.org
 *
 * This file has been generated by build.php from the src/... sources
 * Please don't modify it : modify src/... & rebuild it !
 */

/* FILE src/header.js */
// Ease validators
/* jshint esversion: 9 */
if (!ol) var ol = {};

/**
 * Debug facilities on mobile
 */
if (!location.hash.indexOf('##'))
	window.addEventListener('error', function(evt) {
		alert(evt.filename + ' ' + evt.lineno + ':' + evt.colno + '\n' + evt.message);
	});
if (location.hash == '###')
	console.log = function(message) {
		alert(message);
	};

/**
 * Display misc values
 */
(async function() {
	let data = ['Openlayers ' + ol.version];

	// myol storages in the subdomain
	['localStorage', 'sessionStorage'].forEach(s => {
		if (window[s].length)
			data.push(s + ':');

		Object.keys(window[s])
			.filter(k => k.substring(0, 5) == 'myol_')
			.forEach(k => data.push('  ' + k + ': ' + window[s].getItem(k)));
	});

	// Registered service workers in the scope
	if ('serviceWorker' in navigator)
		await navigator.serviceWorker.getRegistrations().then(registrations => {
			if (registrations.length) {
				data.push('service-workers:');

				for (let registration of registrations)
					if (registration.active)
						data.push('  ' + registration.active.scriptURL);
			}
		});

	if (typeof caches == 'object')
		await caches.keys().then(function(names) {
			if (names.length) {
				data.push('caches:');

				for (let name of names)
					data.push('  ' + name);
			}
		});

	// Final display
	console.info(data.join('\n'));
})();

/**
 * Json parsing errors log
 */
function JSONparse(json) {
	try {
		return JSON.parse(json);
	} catch (returnCode) {
		console.log(returnCode + ' parsing : "' + json + '" ' + new Error().stack);
	}
}

/**
 * IOS 12 support
 */
if (window.PointerEvent === undefined) {
	const script = document.createElement('script');
	script.src = 'https://unpkg.com/elm-pep';
	document.head.appendChild(script);
}

// Icon extension depending on the OS (IOS 12 dosn't support SVG)
function iconCanvasExt() {
	const iOSVersion = navigator.userAgent.match(/iPhone OS ([0-9]+)/);
	return iOSVersion && iOSVersion[1] < 13 ? 'png' : 'svg';
}

/* FILE src/layerTileCollection.js */
/**
 * WMTS EPSG:3857 tiles layers
 */

/**
 * Openstreetmap
 */
function layerOSM(options) {
	return new ol.layer.Tile({
		source: new ol.source.XYZ({
			// url: mandatory
			maxZoom: 21,
			attributions: ol.source.OSM.ATTRIBUTION,
			...options // Include url
		}),
	});
}

function layerOpenTopo() {
	return layerOSM({
		url: '//{a-c}.tile.opentopomap.org/{z}/{x}/{y}.png',
		attributions: '<a href="https://opentopomap.org">OpenTopoMap</a> ' +
			'(<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)',
		maxZoom: 17,
	});
}

function layerMRI() {
	return layerOSM({
		url: '//maps.refuges.info/hiking/{z}/{x}/{y}.png',
		attributions: '<a href="//wiki.openstreetmap.org/wiki/Hiking/mri">Refuges.info</a>',
	});
}

/**
 * Kompas (Austria)
 * Requires layerOSM
 */
function layerKompass(opt) {
	const options = {
		subLayer: 'KOMPASS Touristik',
		...opt
	};

	return layerOSM({
		url: options.key ?
			'https://map{1-4}.kompass.de/{z}/{x}/{y}/' + options.subLayer + '?key=' + options.key : 'https://map{1-5}.tourinfra.com/tiles/kompass_osm/{z}/{x}/{y}.png',
		attributions: '<a href="http://www.kompass.de/livemap/">KOMPASS</a>',
	});
}

/**
 * Thunderforest
 * Requires layerOSM
 */
function layerThunderforest(opt) {
	const options = {
		subLayer: 'outdoors',
		//key: Get a key at https://manage.thunderforest.com/dashboard
		...opt
	};

	if (options.key) // Don't display if no key
		return layerOSM({
			url: '//{a-c}.tile.thunderforest.com/' + options.subLayer +
				'/{z}/{x}/{y}.png?apikey=' + options.key,
			attributions: '<a href="http://www.thunderforest.com">Thunderforest</a>',
			...options // Include key
		});
}

/**
 * IGN France
 * var options.key = Get your own (free)IGN key at https://geoservices.ign.fr/
 * doc : https://geoservices.ign.fr/services-web
 */
function layerIGN(options) {
	let IGNresolutions = [],
		IGNmatrixIds = [];

	for (let i = 0; i < 18; i++) {
		IGNresolutions[i] = ol.extent.getWidth(ol.proj.get('EPSG:3857').getExtent()) / 256 / Math.pow(2, i);
		IGNmatrixIds[i] = i.toString();
	}

	if (options && options.key) // Don't display if no key provided
		return new ol.layer.Tile({
			source: new ol.source.WMTS({
				url: 'https://wxs.ign.fr/' + options.key + '/wmts',
				layer: 'GEOGRAPHICALGRIDSYSTEMS.MAPS', // Top 25
				style: 'normal',
				matrixSet: 'PM',
				format: 'image/jpeg',
				attributions: '&copy; <a href="http://www.geoportail.fr/" target="_blank">IGN</a>',
				tileGrid: new ol.tilegrid.WMTS({
					origin: [-20037508, 20037508],
					resolutions: IGNresolutions,
					matrixIds: IGNmatrixIds,
				}),
				...options // Include key & layer
			}),
		});
}

/**
 * Swisstopo https://api.geo.admin.ch/
 */
function layerSwissTopo(opt) {
	const options = {
			host: 'https://wmts2{0-4}.geo.admin.ch/1.0.0/',
			subLayer: 'ch.swisstopo.pixelkarte-farbe',
			...opt
		},
		projectionExtent = ol.proj.get('EPSG:3857').getExtent(),
		resolutions = [],
		matrixIds = [];

	for (let r = 0; r < 18; ++r) {
		resolutions[r] = ol.extent.getWidth(projectionExtent) / 256 / Math.pow(2, r);
		matrixIds[r] = r;
	}

	return [
		layerStamen('terrain', 300),
		new ol.layer.Tile({
			maxResolution: 300,
			source: new ol.source.WMTS(({
				crossOrigin: 'anonymous',
				url: options.host + options.subLayer +
					'/default/current/3857/{TileMatrix}/{TileCol}/{TileRow}.jpeg',
				tileGrid: new ol.tilegrid.WMTS({
					origin: ol.extent.getTopLeft(projectionExtent),
					resolutions: resolutions,
					matrixIds: matrixIds,
				}),
				requestEncoding: 'REST',
				attributions: '&copy <a href="https://map.geo.admin.ch/">SwissTopo</a>',
			})),
			...options
		}),
	];
}

/**
 * Spain
 */
function layerSpain(opt) {
	const options = {
		host: '//www.ign.es/wmts/',
		server: 'mapa-raster',
		subLayer: 'MTN',
		...opt
	};

	return new ol.layer.Tile({
		source: new ol.source.XYZ({
			url: options.host + options.server + '?layer=' + options.subLayer +
				'&Service=WMTS&Request=GetTile&Version=1.0.0&Format=image/jpeg' +
				'&style=default&tilematrixset=GoogleMapsCompatible' +
				'&TileMatrix={z}&TileCol={x}&TileRow={y}',
			attributions: '&copy; <a href="http://www.ign.es/">IGN España</a>',
			...options
		}),
	});
}

/**
 * Italy IGM
 */
function layerIGM() {
	return [
		subLayerIGM('IGM_25000', 'CB.IGM25000', 5, 10),
		subLayerIGM('IGM_100000', 'MB.IGM100000', 10, 20),
		subLayerIGM('IGM_250000', 'CB.IGM250000', 20, 120),
		layerStamen('terrain', 120),
	];

	function subLayerIGM(url, layer, minResolution, maxResolution) {
		return new ol.layer.Tile({
			minResolution: minResolution,
			maxResolution: maxResolution,
			source: new ol.source.TileWMS({
				url: 'https://chemineur.fr/assets/proxy/?s=minambiente.it&type=png' + // Not available via https
					'&map=/ms_ogc/WMS_v1.3/raster/' + url + '.map',
				params: {
					layers: layer,
				},
				attributions: '&copy <a href="http://www.pcn.minambiente.it/viewer/">IGM</a>',
			}),
		});
	}
}

/**
 * Ordnance Survey : Great Britain
 */
function layerOS(opt) {
	const options = {
		subLayer: 'Outdoor_3857',
		// key: Get your own (free) key at https://osdatahub.os.uk/
		...opt
	};

	if (options.key)
		return [
			layerStamen('terrain', 1700),
			new ol.layer.Tile({
				extent: [-1198263, 6365000, 213000, 8702260],
				minResolution: 2,
				maxResolution: 1700,
				source: new ol.source.XYZ({
					url: 'https://api.os.uk/maps/raster/v1/zxy/' + options.subLayer +
						'/{z}/{x}/{y}.png?key=' + options.key,
					attributions: '&copy <a href="https://explore.osmaps.com">UK Ordnancesurvey maps</a>',
					...options // Include key
				}),
			}),
		];
}

/**
 * ArcGIS (Esri)
 */
function layerArcGIS(opt) {
	const options = {
		host: 'https://server.arcgisonline.com/ArcGIS/rest/services/',
		subLayer: 'World_Imagery',
		...opt
	};

	return new ol.layer.Tile({
		source: new ol.source.XYZ({
			url: options.host + options.subLayer +
				'/MapServer/tile/{z}/{y}/{x}',
			maxZoom: 19,
			attributions: '&copy; <a href="https://www.arcgis.com/home/webmap/viewer.html">ArcGIS (Esri)</a>',
		}),
	});
}

/**
 * Stamen http://maps.stamen.com
 */
function layerStamen(subLayer, minResolution) {
	return new ol.layer.Tile({
		source: new ol.source.Stamen({
			layer: subLayer,
		}),
		minResolution: minResolution || 0,
	});
}

/**
 * Google
 */
function layerGoogle(subLayer) {
	return new ol.layer.Tile({
		source: new ol.source.XYZ({
			url: '//mt{0-3}.google.com/vt/lyrs=' + subLayer + '&hl=fr&x={x}&y={y}&z={z}',
			attributions: '&copy; <a href="https://www.google.com/maps">Google</a>',
		}),
	});
}

/**
 * Bing (Microsoft)
 * options.imagerySet: sublayer
 * options.key: Get your own (free) key at https://www.bingmapsportal.com
 * Doc at: https://docs.microsoft.com/en-us/bingmaps/getting-started/
 * attributions: defined by ol.source.BingMaps
 */
function layerBing(options) {
	if (options && options.key) { // Don't display if no key provided
		const layer = new ol.layer.Tile();

		layer.on('change:visible', function(evt) {
			if (evt.target.getVisible() && // When the layer becomes visible
				!layer.getSource()) { // Only once
				layer.setSource(new ol.source.BingMaps(options));
			}
		});

		return layer;
	}
}

/**
 * Tile layers examples
 */
function layerTileCollection(options) {
	options = options || {};

	return {
		'OSM fr': layerOSM({
			url: '//{a-c}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png',
		}),
		'OpenTopo': layerOpenTopo(),
		'OSM outdoors': layerThunderforest(options.thunderforest), // options include key
		'OSM transports': layerThunderforest({
			...options.thunderforest, // Include key
			subLayer: 'transport',
		}),
		'OSM cyclo': layerOSM({
			url: '//{a-c}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png',
		}),
		'Refuges.info': layerMRI(),

		'IGN TOP25': layerIGN(options.ign), // options include key
		'IGN V2': layerIGN({
			layer: 'GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2',
			key: 'essentiels',
			format: 'image/png',
		}),
		'IGN cartes 1950': layerIGN({
			layer: 'GEOGRAPHICALGRIDSYSTEMS.MAPS.SCAN50.1950',
			key: 'cartes/geoportail',
		}),

		'SwissTopo': layerSwissTopo(),
		'Autriche': layerKompass(), // No key
		'Angleterre': layerOS(options.os), // options include key
		'Italie': layerIGM(),
		'Espagne': layerSpain(),

		'Photo Google': layerGoogle('s'),
		'Photo ArcGIS': layerArcGIS(),
		'Photo Bing': layerBing({
			...options.bing, // Include key
			imagerySet: 'Aerial',
		}),
		'Photo IGN': layerIGN({
			layer: 'ORTHOIMAGERY.ORTHOPHOTOS',
			key: 'essentiels',
		}),

		'Photo IGN 1950-65': layerIGN({
			layer: 'ORTHOIMAGERY.ORTHOPHOTOS.1950-1965',
			key: 'orthohisto/geoportail',
			style: 'BDORTHOHISTORIQUE',
			format: 'image/png',
		}),

		'IGN E.M. 1820-66': layerIGN({
			layer: 'GEOGRAPHICALGRIDSYSTEMS.ETATMAJOR40',
			key: 'cartes/geoportail',
		}),
		'Cadastre': layerIGN({
			layer: 'CADASTRALPARCELS.PARCELLAIRE_EXPRESS',
			key: 'essentiels',
			format: 'image/png',
		}),
		/*'IGN Cassini': layerIGN({
			...options.ign,
					layer: 'GEOGRAPHICALGRIDSYSTEMS.CASSINI',
				}),*/
	};
}

function layersDemo(options) {
	return {
		...layerTileCollection(options),

		'OSM': layerOSM({
			url: '//{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png',
		}),

		'ThF cycle': layerThunderforest({
			...options.thunderforest, // Include key
			subLayer: 'cycle',
		}),
		'ThF trains': layerThunderforest({
			...options.thunderforest, // Include key
			subLayer: 'pioneer',
		}),
		'ThF villes': layerThunderforest({
			...options.thunderforest, // Include key
			subLayer: 'neighbourhood',
		}),
		'ThF landscape': layerThunderforest({
			...options.thunderforest, // Include key
			subLayer: 'landscape',
		}),
		'ThF contraste': layerThunderforest({
			...options.thunderforest, // Include key
			subLayer: 'mobile-atlas',
		}),

		'OS light': layerOS({
			...options.os, // Include key
			subLayer: 'Light_3857',
		}),
		'OS road': layerOS({
			...options.os, // Include key
			subLayer: 'Road_3857',
		}),
		'Kompas topo': layerKompass({
			...options.kompass, // Include key
			subLayer: 'kompass_topo',
		}),
		'Kompas winter': layerKompass({
			...options.kompass, // Include key
			subLayer: 'kompass_winter',
		}),

		'Bing': layerBing({
			...options.bing, // Include key
			imagerySet: 'Road',
		}),
		'Bing hybrid': layerBing({
			...options.bing, // Include key
			imagerySet: 'AerialWithLabels',
		}),

		'Photo Swiss': layerSwissTopo({
			subLayer: 'ch.swisstopo.swissimage',
		}),
		'Photo Espagne': layerSpain({
			server: 'pnoa-ma',
			subLayer: 'OI.OrthoimageCoverage',
		}),

		'Google road': layerGoogle('m'),
		'Google terrain': layerGoogle('p'),
		'Google hybrid': layerGoogle('s,h'),
		'Stamen': layerStamen('terrain'),
		'Toner': layerStamen('toner'),
		'Watercolor': layerStamen('watercolor'),
		'Blank': new ol.layer.Tile(),
	};
}

/* FILE src/layerVector.js */
/**
 * Adds some facilities to ol.layer.Vector
 */

/**
 * Layer to display remote geoJson
 * Styles, icons & labels
 *
 * Options:
 * selectName : <input name="SELECT_NAME"> url arguments selector
   can be several SELECT_NAME_1,SELECT_NAME_2,...
   display loading status <TAG id="SELECT_NAME-status"></TAG>
   No selectName will display the layer
   No selector with selectName will hide the layer
 * callBack : function to call when selected 
 * urlArgsFnc: function(layer_options, bbox, selections, extent, resolution, projection)
   returning an object describing the args. The .url member defines the url
 * convertProperties: function(properties, feature, options) convert some server properties to the one displayed by this package
 * styleOptFnc: function(feature, properties, options) returning options of the style of the features
 * styleOptClusterFnc: function(feature, properties, options) returning options of the style of the cluster bullets
 * hoverStyleOptFnc: function(feature, properties, options) returning options of the style when hovering the features
 * source.Vector options : format, strategy, attributions, ...
 * altLayer : another layer to add to the map with this one (for resolution depending layers)
 */
function layerVector(opt) {
	const options = {
			selectName: '',
			callBack: function() {
				layer.setVisible(
					!selectNames[0] || // No selector name
					selectVectorLayer(selectNames[0]).length // By default, visibility depends on the first selector only
				);
				source.refresh();
			},
			styleOptClusterFnc: styleOptCluster,
			...opt
		},
		selectNames = (options.selectName || '').split(','),
		format = new ol.format.GeoJSON(),
		source = new ol.source.Vector({
			url: url,
			format: format,
			strategy: ol.loadingstrategy.bbox,
			...options
		}),
		layer = new ol.layer.Vector({
			source: source,
			style: style,
			zIndex: 10, // Features : above the base layer (zIndex = 1)
			...options
		}),
		statusEl = document.getElementById(selectNames[0] + '-status'); // XHR download tracking

	layer.setMapInternal = function(map) {
		ol.layer.Vector.prototype.setMapInternal.call(this, map);

		// Add the alternate layer if any
		if (options.altLayer)
			map.addLayer(options.altLayer);

		// Add a layer to manage hovered features (once for a map)
		if (!map.layerHover && !options.noHover)
			map.layerHover = layerHover(map);
	};

	layer.hoverStyleOptFnc = options.hoverStyleOptFnc; // Embark hover style to render hovering
	selectNames.map(name => selectVectorLayer(name, options.callBack)); // Setup the selector managers
	options.callBack(); // Init parameters depending on the selector

	// Default url callback function for the layer
	function url(extent, resolution, projection) {
		const args = options.urlArgsFnc(
				options, // Layer options
				ol.proj.transformExtent( // BBox
					extent,
					projection.getCode(), // Map projection
					'EPSG:4326' // Received projection
				)
				.map(c => c.toFixed(4)), // Round to 4 digits
				selectNames.map(name => selectVectorLayer(name).join(',')), // Array of string: selected values separated with ,
				extent,
				resolution
			),
			query = [];

		// Add a version param depending on last change date to reload if modified
		if (sessionStorage.myol_lastChangeTime)
			args.v = parseInt((sessionStorage.myol_lastChangeTime % 100000000) / 10000);

		for (const a in args)
			if (a != 'url' && args[a])
				query.push(a + '=' + args[a]);

		return args.url + '?' + query.join('&');
	}

	// Display loading status
	if (statusEl)
		source.on(['featuresloadstart', 'featuresloadend', 'featuresloaderror'], function(evt) {
			if (!statusEl.textContent.includes('error'))
				statusEl.innerHTML = '';

			switch (evt.type) {
				case 'featuresloadstart':
					statusEl.innerHTML = '&#8987;';
					break;
				case 'featuresloaderror':
					statusEl.innerHTML = 'Erreur !';
			}
		});

	format.readFeatures = function(doc, opt) {
		const json = JSONparse(doc);

		// For all features
		json.features.map(feature => {
			// Generate a pseudo id if none
			if (!feature.id)
				feature.id = JSON.stringify(feature.properties).replace(/\D/g, '') % 987654;

			// Callback function to convert some server properties to the one displayed by this package
			if (typeof options.convertProperties == 'function')
				feature.properties = {
					...feature.properties,
					...options.convertProperties(feature.properties, options),
				};

			// Add +- 0.00005° (5m) random to each coordinate to separate the points having the same coordinates
			if (feature.geometry.type == 'Point ') {
				const rnd = (feature.id / 3.14).toString().split('.');

				feature.geometry.coordinates[0] += ('0.0000' + rnd[0]) - 0.00005;
				feature.geometry.coordinates[1] += ('0.0000' + rnd[1]) - 0.00005;
			}
			return feature;
		});

		return ol.format.GeoJSON.prototype.readFeatures.call(this, JSON.stringify(json), opt);
	};

	// Style callback function for the layer
	function style(feature) {
		const properties = feature.getProperties(),
			styleOptFnc = properties.features || properties.cluster ?
			options.styleOptClusterFnc :
			options.styleOptFnc;

		if (typeof styleOptFnc == 'function')
			return new ol.style.Style(
				styleOptFnc(
					feature,
					properties
				)
			);
	}

	return layer;
}

/**
 * Clustering features
 */
function layerVectorCluster(opt) {
	const options = {
			distance: 30, // Minimum distance between clusters
			density: 1000, // Maximum number of displayed clusters
			...opt
		},
		layer = layerVector(options), // Basic layer (with all the points)
		clusterSource = new ol.source.Cluster({
			source: layer.getSource(),
			geometryFunction: geometryFnc,
			createCluster: createCluster,
			distance: options.distance,
		}),
		clusterLayer = new ol.layer.Vector({
			source: clusterSource,
			style: (feature, resolution) => layer.getStyleFunction()(feature, resolution),
			visible: layer.getVisible(),
			zIndex: layer.getZIndex(),
			...options
		});


	clusterLayer.setMapInternal = layer.setMapInternal;
	clusterLayer.hoverStyleOptFnc = options.hoverStyleOptFnc; // Embark hover style to render hovering

	// Propagate setVisible following the selector status
	layer.on('change:visible', () =>
		clusterLayer.setVisible(layer.getVisible())
	);

	// Tune the clustering distance depending on the zoom level
	clusterLayer.on('prerender', evt => {
		const surface = evt.context.canvas.width * evt.context.canvas.height, // Map pixels number
			distanceMinCluster = Math.min(
				evt.frameState.viewState.resolution, // No clusterisation on low resolution zooms
				Math.max(options.distance, Math.sqrt(surface / options.density))
			);

		if (clusterSource.getDistance() != distanceMinCluster) // Only when changed
			clusterSource.setDistance(distanceMinCluster);
	});

	// Generate a center point to manage clusterisations
	function geometryFnc(feature) {
		const extent = feature.getGeometry().getExtent(),
			pixelSemiPerimeter = (extent[2] - extent[0] + extent[3] - extent[1]) / this.resolution;

		// Don't cluster lines or polygons whose the extent perimeter is more than 400 pixels
		if (pixelSemiPerimeter > 200)
			clusterSource.addFeature(feature);
		else
			return new ol.geom.Point(
				ol.extent.getCenter(
					feature.getGeometry().getExtent()
				)
			);
	}

	// Generate the features to render the cluster
	function createCluster(point, features) {
		// Single feature : display it
		if (features.length == 1)
			return features[0];

		// Display a cluster point
		return new ol.Feature({
			geometry: point,
			features: features
		});
	}

	return clusterLayer;
}

/**
 * Some usefull style functions
 */

// Get icon from an URL
function styleOptIcon(iconUrl) {
	if (iconUrl)
		return {
			image: new ol.style.Icon({
				src: iconUrl,
			}),
		};
}

// Get icon from chemineur.fr
function styleOptIconChemineur(iconName) {
	if (iconName) {
		const icons = iconName.split(' ');

		iconName = icons[0] + (icons.length > 1 ? '_' + icons[1] : ''); // Limit to 2 type names & ' ' -> '_'

		return styleOptIcon('//chemineur.fr/ext/Dominique92/GeoBB/icones/' + iconName + '.' + iconCanvasExt());
	}
}

// Display a label with some data about the feature
function styleOptFullLabel(feature, properties) {
	let text = [],
		line = [];

	// Cluster
	if (properties.features || properties.cluster) {
		let includeCluster = !!properties.cluster;

		for (let f in properties.features) {
			const name = properties.features[f].getProperties().name;
			if (name)
				text.push(name);
			if (properties.features[f].getProperties().cluster)
				includeCluster = true;
		}
		if (text.length == 0 || text.length > 6 || includeCluster)
			text = ['Cliquer pour zoomer'];
	}
	// Feature
	else {
		// 1st line
		if (properties.name)
			text.push(properties.name);

		// 2nd line
		if (properties.ele)
			line.push(parseInt(properties.ele) + ' m');
		if (properties.capacity)
			line.push(parseInt(properties.capacity) + '\u255E\u2550\u2555');
		if (line.length)
			text.push(line.join(', '));

		// 3rd line
		if (typeof properties.type == 'string' && properties.type)
			text.push(
				properties.type[0].toUpperCase() +
				properties.type.substring(1).replace('_', ' ')
			);

		// 4rd line
		if (properties.attribution)
			text.push('&copy;' + properties.attribution);
	}

	return styleOptLabel(text.join('\n'), feature, properties, true);
}

// Display a label with only the name
function styleOptLabel(text, feature, properties, important) {

	const elLabel = document.createElement('span'),
		area = ol.extent.getArea(feature.getGeometry().getExtent()), // Detect lines or polygons
		styleTextOptions = {
			textBaseline: area ? 'middle' : 'bottom',
			offsetY: area ? 0 : -14, // Above the icon
			padding: [1, 1, 0, 3],
			font: '14px Calibri,sans-serif',
			fill: new ol.style.Fill({
				color: 'black',
			}),
			backgroundFill: new ol.style.Fill({
				color: 'white',
			}),
			backgroundStroke: new ol.style.Stroke({
				color: 'blue',
				width: important ? 1 : 0.3,
			}),
			overflow: important,
		};

	elLabel.innerHTML = text;
	styleTextOptions.text = elLabel.innerHTML;

	return {
		text: new ol.style.Text(styleTextOptions),
	};
}

// Apply a color and transparency to a polygon
function styleOptPolygon(color, transparency) { // color = #rgb, transparency = 0 to 1
	if (color)
		return {
			fill: new ol.style.Fill({
				color: 'rgba(' + [
					parseInt(color.substring(1, 3), 16),
					parseInt(color.substring(3, 5), 16),
					parseInt(color.substring(5, 7), 16),
					transparency || 1,
				].join(',') + ')',
			})
		};
}

// Style of a cluster bullet (both local & server cluster
function styleOptCluster(feature, properties) {
	let nbClusters = parseInt(properties.cluster || 0);

	for (let f in properties.features)
		nbClusters += parseInt(properties.features[f].getProperties().cluster || 1);

	return {
		image: new ol.style.Circle({
			radius: 14,
			stroke: new ol.style.Stroke({
				color: 'blue',
			}),
			fill: new ol.style.Fill({
				color: 'white',
			}),
		}),
		text: new ol.style.Text({
			text: nbClusters.toString(),
			font: '14px Calibri,sans-serif',
		}),
	};
}

/**
 * Global hovering functions layer
   To be declared & added once for a map
 */
function layerHover(map) {
	const source = new ol.source.Vector(),
		layer = new ol.layer.Vector({
			source: source,
		});

	map.addLayer(layer);

	// Leaving the map reset hovering
	window.addEventListener('mousemove', evt => {
		const divRect = map.getTargetElement().getBoundingClientRect();

		// The mouse is outside of the map
		if (evt.clientX < divRect.left || divRect.right < evt.clientX ||
			evt.clientY < divRect.top || divRect.bottom < evt.clientY)
			source.clear();
	});

	map.on(['pointermove', 'click'], (evt) => {
		// Find hovered feature
		const map = evt.target,
			found = map.forEachFeatureAtPixel(
				map.getEventPixel(evt.originalEvent),
				hoverFeature, {
					hitTolerance: 6, // Default 0
				}
			);

		// Erase existing hover if nothing found
		map.getViewport().style.cursor = found ? 'pointer' : '';
		if (!found)
			source.clear();

		function hoverFeature(hoveredFeature, hoveredLayer) {
			const hoveredProperties = hoveredFeature.getProperties();

			// Click on a feature
			if (evt.type == 'click') {
				if (hoveredProperties.url) {
					// Open a new tag
					if (evt.originalEvent.ctrlKey)
						window.open(hoveredProperties.url, '_blank').focus();
					else
						// Open a new window
						if (evt.originalEvent.shiftKey)
							window.open(hoveredProperties.url, '_blank', 'resizable=yes').focus();
						else
							// Go on the same window
							window.location.href = hoveredProperties.url;
				}
				// Cluster
				else if (hoveredProperties.features)
					map.getView().animate({
						zoom: map.getView().getZoom() + 2,
						center: hoveredProperties.geometry.getCoordinates(),
					});
			}

			// Over the hover (Label ?)
			if (hoveredLayer.ol_uid == layer.ol_uid)
				return true; // Don't undisplay it

			// Hover a feature
			if (typeof hoveredLayer.hoverStyleOptFnc == 'function') {
				source.clear();
				source.addFeature(hoveredFeature);
				layer.setStyle(new ol.style.Style(
					hoveredLayer.hoverStyleOptFnc(
						hoveredFeature,
						hoveredProperties
					)
				));
				layer.setZIndex(hoveredLayer.getZIndex() + 2); // Tune the hoverLayer zIndex just above the hovered layer

				return hoveredFeature; // Don't continue
			}
		}
	});

	return layer;
}

/**
 * BBOX strategy when the url returns a limited number of features in the BBox
 * We do need to reload when the zoom in
 */
ol.loadingstrategy.bboxLimit = function(extent, resolution) {
	if (this.bboxLimitResolution > resolution) // When zoom in
		this.refresh(); // Force the loading of all areas
	this.bboxLimitResolution = resolution; // Mem resolution for further requests
	return [extent];
};

/**
 * Manage a collection of checkboxes with the same name
 * There can be several selectors for one layer
 * A selector can be used by several layers
 * The checkbox without value check / uncheck the others
 * Current selection is saved in window.localStorage
 * name : input names
 * callBack : callback function (this reset the checkboxes)
 * You can force the values in window.localStorage[simplified name]
 * Return return an array of selected values
 */
function selectVectorLayer(name, callBack) {
	const selectEls = [...document.getElementsByName(name)],
		safeName = 'myol_' + name.replace(/[^a-z]/ig, ''),
		init = (localStorage[safeName] || '').split(',');

	// Init
	if (typeof callBack == 'function') {
		selectEls.forEach(el => {
			el.checked =
				init.includes(el.value) ||
				init.includes('all') ||
				init.join(',') == el.value;
			el.addEventListener('click', onClick);
		});
		onClick();
	}

	function onClick(evt) {
		// Test the "all" box & set other boxes
		if (evt && evt.target.value == 'all')
			selectEls
			.forEach(el => el.checked = evt.target.checked);

		// Test if all values are checked
		const allChecked = selectEls
			.filter(el => !el.checked && el.value != 'all');

		// Set the "all" box
		selectEls
			.forEach(el => {
				if (el.value == 'all')
					el.checked = !allChecked.length;
			});

		// Save the current status
		if (selection().length)
			localStorage[safeName] = selection().join(',');
		else
			delete localStorage[safeName];

		if (evt)
			callBack(selection());
	}

	function selection() {
		return selectEls
			.filter(el => el.checked && el.value != 'all')
			.map(el => el.value);
	}

	return selection();
}

/* FILE src/layerVectorCollection.js */
/**
 * This file implements various acces to geoJson services
 * using MyOl/src/layerVector.js
 */

/**
 * Site chemineur.fr, alpages.info
 * layer: verbose (full data) | cluster (grouped points) | '' (simplified)
 */
function layerGeoBB(options) {
	return layerVectorCluster({
		host: '//chemineur.fr/',
		urlArgsFnc: function(opt, bbox, selections) {
			return {
				url: opt.host + 'ext/Dominique92/GeoBB/gis.php',
				cat: selections[0], // The 1st (and only selector)
				limit: 10000,
				...opt.extraParams(bbox),
			};
		},
		selectName: 'select-chem',
		extraParams: function(bbox) {
			return {
				bbox: bbox.join(','),
			};
		},
		convertProperties: function(properties, opt) {
			return {
				icon: properties.type ?
					opt.host + 'ext/Dominique92/GeoBB/icones/' + properties.type + '.' + iconCanvasExt() : null,
				url: properties.id ?
					opt.host + 'viewtopic.php?t=' + properties.id : null,
				attribution: opt.attribution,
			};
		},
		styleOptFnc: function(f, properties) {
			return {
				...styleOptIcon(properties.icon), // Points
				...styleOptPolygon(properties.color, 0.5), // Polygons with color
				stroke: new ol.style.Stroke({ // Lines
					color: 'blue',
					width: 2,
				}),
			};
		},
		hoverStyleOptFnc: function(feature, properties) {
			return {
				...styleOptFullLabel(feature, properties), // Labels
				stroke: new ol.style.Stroke({ // Lines
					color: 'red',
					width: 3,
				}),
			};
		},
		...options
	});
}

function layerClusterGeoBB(opt) {
	const options = {
			transitionResolution: 100,
			...opt
		},
		clusterLayer = layerGeoBB({
			minResolution: options.transitionResolution,
			extraParams: function(bbox) {
				return {
					layer: 'cluster',
					bbox: bbox.join(','),
				};
			},
			...options
		});

	return layerGeoBB({
		maxResolution: options.transitionResolution,
		altLayer: clusterLayer,
		...options
	});
}

/**
 * Site refuges.info
 */
function layerWri(options) {
	return layerVectorCluster({
		host: '//www.refuges.info/',
		urlArgsFnc: function(opt, bbox, selections) {
			return {
				url: opt.host + (selections[1] ? 'api/massif' : 'api/bbox'),
				type_points: selections[0],
				massif: selections[1],
				nb_points: 'all',
				...opt.extraParams(bbox),
			};
		},
		selectName: 'select-wri',
		extraParams: function(bbox) {
			return {
				bbox: bbox.join(','),
			};
		},
		convertProperties: function(properties, opt) {
			return {
				type: properties.type.valeur,
				name: properties.nom,
				icon: opt.host + 'images/icones/' + properties.type.icone + '.' + iconCanvasExt(),
				ele: properties.coord ? properties.coord.alt : null,
				capacity: properties.places ? properties.places.valeur : null,
				url: opt.noClick ? null : properties.lien,
				attribution: opt.attribution,
			};
		},
		styleOptFnc: function(f, properties) {
			return styleOptIcon(properties.icon);
		},
		hoverStyleOptFnc: function(feature, properties) {
			return styleOptFullLabel(feature, properties);
		},
		attribution: 'refuges.info',
		...options
	});
}

function layerClusterWri(opt) {
	const options = {
			transitionResolution: 100,
			...opt
		},
		clusterLayer = layerWri({
			minResolution: options.transitionResolution,
			strategy: ol.loadingstrategy.all,
			extraParams: function() {
				return {
					cluster: 0.1,
				};
			},
			...options
		});

	return layerWri({
		maxResolution: options.transitionResolution,
		altLayer: clusterLayer,
		...options
	});
}

function layerWriAreas(options) {
	return layerVector({
		host: '//www.refuges.info/',
		strategy: ol.loadingstrategy.all,
		polygon: 1, // Massifs
		zIndex: 2, // Behind points
		urlArgsFnc: function(opt) {
			return {
				url: opt.host + 'api/polygones',
				type_polygon: opt.polygon,
			};
		},
		selectName: 'select-massifs',
		convertProperties: function(properties) {
			return {
				name: properties.nom,
				color: properties.couleur,
				url: properties.lien,
			};
		},
		styleOptFnc: function(feature, properties) {
			return {
				...styleOptLabel(properties.name, feature, properties),
				...styleOptPolygon(properties.color, 0.5),
			};
		},
		hoverStyleOptFnc: function(feature, properties) {
			// Invert previous color
			const colors = properties.color
				.match(/([0-9a-f]{2})/ig)
				.map(c =>
					(255 - parseInt(c, 16))
					.toString(16).padStart(2, '0')
				)
				.join('');

			return {
				...styleOptLabel(properties.name, feature, properties, true),
				...styleOptPolygon('#' + colors, 0.3),
				stroke: new ol.style.Stroke({
					color: properties.color,
					width: 3,
				}),
			};
		},
		...options
	});
}

/**
 * Site pyrenees-refuges.com
 */
function layerPrc(options) {
	return layerVectorCluster({
		url: 'https://www.pyrenees-refuges.com/api.php?type_fichier=GEOJSON',
		selectName: 'select-prc',
		strategy: ol.loadingstrategy.all,
		convertProperties: function(properties) {
			return {
				type: properties.type_hebergement,
				url: properties.url,
				ele: properties.altitude,
				capacity: properties.cap_ete,
				attribution: 'Pyrenees-Refuges',
			};
		},
		styleOptFnc: function(f, properties) {
			return styleOptIconChemineur(properties.type_hebergement);
		},
		hoverStyleOptFnc: function(feature, properties) {
			return styleOptFullLabel(feature, properties);
		},
		...options
	});
}

/**
 * Site camptocamp.org
 */
function layerC2C(options) {
	const format = new ol.format.GeoJSON({ // Format of received data
		dataProjection: 'EPSG:3857',
	});

	format.readFeatures = function(json, opt) {
		const features = [],
			objects = JSONparse(json);

		for (let o in objects.documents) {
			const properties = objects.documents[o];

			features.push({
				id: properties.document_id,
				type: 'Feature',
				geometry: JSONparse(properties.geometry.geom),
				properties: {
					type: properties.waypoint_type,
					name: properties.locales[0].title,
					ele: properties.elevation,
					url: '//www.camptocamp.org/waypoints/' + properties.document_id,
					attribution: 'campTOcamp',
				},
			});
		}
		return format.readFeaturesFromObject({
				type: 'FeatureCollection',
				features: features,
			},
			format.getReadOptions(json, opt)
		);
	};

	return layerVectorCluster({
		urlArgsFnc: function(o, b, s, extent) {
			return {
				url: 'https://api.camptocamp.org/waypoints',
				bbox: extent.join(','),
			};
		},
		selectName: 'select-c2c',
		format: format,
		styleOptFnc: function(f, properties) {
			return styleOptIconChemineur(properties.type);
		},
		hoverStyleOptFnc: function(feature, properties) {
			return styleOptFullLabel(feature, properties);
		},
		...options
	});
}

/**
 * OSM XML overpass POI layer
 * From: https://openlayers.org/en/latest/examples/vector-osm.html
 * Doc: http://wiki.openstreetmap.org/wiki/Overpass_API/Language_Guide
 */
function layerOverpass(opt) {
	const format = new ol.format.OSMXML(),
		options = {
			//host: 'overpass-api.de',
			//host: 'lz4.overpass-api.de',
			//host: 'overpass.openstreetmap.fr', // Out of order
			host: 'overpass.kumi.systems',
			//host: 'overpass.nchc.org.tw',

			selectName: 'select-osm',
			maxResolution: 50,
			styleOptFnc: function(f, properties) {
				return styleOptIconChemineur(properties.type);
			},
			hoverStyleOptFnc: function(feature, properties) {
				return styleOptFullLabel(feature, properties);
			},
			...opt
		},
		layer = layerVectorCluster({
			urlArgsFnc: urlArgsFnc,
			format: format,
			...options
		}),
		statusEl = document.getElementById(options.selectName),
		selectEls = document.getElementsByName(options.selectName);

	// List of acceptable tags in the request return
	let tags = '';

	for (let e in selectEls)
		if (selectEls[e].value)
			tags += selectEls[e].value.replace('private', '');

	function urlArgsFnc(o, bbox, selections) {
		const items = selections[0].split(','), // The 1st (and only selector)
			bb = '(' + bbox[1] + ',' + bbox[0] + ',' + bbox[3] + ',' + bbox[2] + ');',
			args = [];

		// Convert selected items on overpass_api language
		for (let l = 0; l < items.length; l++) {
			const champs = items[l].split('+');

			for (let ls = 0; ls < champs.length; ls++)
				args.push(
					'node' + champs[ls] + bb + // Ask for nodes in the bbox
					'way' + champs[ls] + bb // Also ask for areas
				);
		}

		return {
			url: 'https://' + options.host + '/api/interpreter',
			data: '[timeout:5];(' + args.join('') + ');out center;',
		};
	}

	// Extract features from data when received
	format.readFeatures = function(doc, opt) {
		// Transform an area to a node (picto) at the center of this area

		for (let node = doc.documentElement.firstElementChild; node; node = node.nextSibling) {
			// Translate attributes to standard MyOl
			for (let tag = node.firstElementChild; tag; tag = tag.nextSibling)
				if (tag.attributes) {
					if (tags.indexOf(tag.getAttribute('k')) !== -1 &&
						tags.indexOf(tag.getAttribute('v')) !== -1 &&
						tag.getAttribute('k') != 'type') {
						addTag(node, 'type', tag.getAttribute('v'));
						// Only once for a node
						addTag(node, 'url', 'https://www.openstreetmap.org/node/' + node.id);
						addTag(node, 'attribution', 'osm');
					}

					if (tag.getAttribute('k') && tag.getAttribute('k').includes('capacity:'))
						addTag(node, 'capacity', tag.getAttribute('v'));
				}

			// Create a new 'node' element centered on the surface
			if (node.nodeName == 'way') {
				const newNode = doc.createElement('node');
				newNode.id = node.id;
				doc.documentElement.appendChild(newNode);

				// Browse <way> attributes to build a new node
				for (let subTagNode = node.firstElementChild; subTagNode; subTagNode = subTagNode.nextSibling)
					switch (subTagNode.nodeName) {
						case 'center':
							// Set node attributes
							newNode.setAttribute('lon', subTagNode.getAttribute('lon'));
							newNode.setAttribute('lat', subTagNode.getAttribute('lat'));
							newNode.setAttribute('nodeName', subTagNode.nodeName);
							break;

						case 'tag': {
							// Get existing properties
							newNode.appendChild(subTagNode.cloneNode());

							// Add a tag to mem what node type it was (for link build)
							addTag(newNode, 'nodetype', node.nodeName);
						}
					}
			}

			// Status 200 / error message
			if (node.nodeName == 'remark' && statusEl)
				statusEl.textContent = node.textContent;
		}

		function addTag(node, k, v) {
			const newTag = doc.createElement('tag');
			newTag.setAttribute('k', k);
			newTag.setAttribute('v', v);
			node.appendChild(newTag);
		}

		return ol.format.OSMXML.prototype.readFeatures.call(this, doc, opt);
	};

	return layer;
}

/**
 * Vectors layers examples
 */
function layerVectorCollection(options) {
	options = options || {};

	return [
		layerClusterWri(options.wri),
		layerWriAreas(options.wriAreas),
		layerPrc(options.prc),
		layerC2C(options.c2c),
		layerClusterGeoBB({
			attribution: 'Chemineur',
			...options.chemineur
		}),
		layerGeoBB({
			strategy: ol.loadingstrategy.all,
			host: '//alpages.info/',
			selectName: 'select-alpages',
			attribution: 'Alpages',
			...options.alpages
		}),
		layerOverpass(options.osm),
	];
}

/* FILE src/controls.js */
/**
 * Add some usefull controls
 * Need to include controls.css
 */

/**
 * Control button
 * Abstract definition to be used by other control buttons definitions
 */
function controlButton(opt) {
	const options = {
			element: document.createElement('div'),
			className: '',
			...opt
		},
		control = new ol.control.Control(options),
		buttonEl = document.createElement('button');

	// Add submenu below the button
	if (options.submenuEl)
		control.submenuEl = options.submenuEl;
	else if (options.submenuId)
		control.submenuEl = document.getElementById(options.submenuId);
	else {
		control.submenuEl = document.createElement('div');
		if (options.submenuHTML)
			control.submenuEl.innerHTML = options.submenuHTML;
	}

	// Display the button only if there are no label or submenu
	if (!options.label || !control.submenuEl || !control.submenuEl.innerHTML)
		return control;

	// Populate control & button
	buttonEl.setAttribute('type', 'button');
	buttonEl.innerHTML = options.label;
	control.element.appendChild(buttonEl);
	control.element.className = 'ol-control myol-button ' + options.className;

	// Add submenu
	control.element.appendChild(control.submenuEl);

	// Assign button actions
	control.element.addEventListener('mouseover', action);
	control.element.addEventListener('mouseout', action);
	buttonEl.addEventListener('click', action);

	function action(evt) {
		if (evt.type == 'mouseover')
			control.element.classList.add('myol-button-hover');
		else // mouseout | click
			control.element.classList.remove('myol-button-hover');

		if (evt.type == 'click') // Mouse click & touch
			control.element.classList.toggle('myol-button-selected');

		// Close other open buttons
		for (let el of document.getElementsByClassName('myol-button'))
			if (el != control.element)
				el.classList.remove('myol-button-selected');
	}

	// Close submenu when click or touch on the map
	document.addEventListener('click', evt => {
		const hoveredEl = document.elementFromPoint(evt.x, evt.y);

		if (hoveredEl && hoveredEl.tagName == 'CANVAS')
			control.element.classList.remove('myol-button-selected');
	});

	// Assign control.function to submenu elements events
	// with attribute ctrlOnClic="function" or ctrlOnChange="function"
	for (let el of control.submenuEl.getElementsByTagName('*'))
		['OnClick', 'OnChange'].forEach(evtName => {
			const evtFnc = el.getAttribute('ctrl' + evtName);
			if (evtFnc)
				el[evtName.toLowerCase()] = function(evt) {
					// Check at execution time if control.function() is defined
					if (typeof control[evtFnc] == 'function')
						control[evtFnc](evt);

					return false; // Don't continue on href
				};
		});

	return control;
}

/**
 * Permalink control
 * "map" url hash or localStorage: zoom=<ZOOM> lon=<LON> lat=<LAT>
 * Don't set view when you declare the map
 */
function controlPermalink(opt) {
	const options = {
			init: true, // {true | false} use url hash or localStorage to position the map.
			setUrl: false, // {true | false} Change url hash when moving the map.
			display: false, // {true | false} Display permalink link the map.
			hash: '?', // {?, #} the permalink delimiter after the url
			...opt
		},
		control = new ol.control.Control({
			element: document.createElement('div'),
			render: render,
		}),
		aEl = document.createElement('a'),
		urlMod = location.href.replace( // Get value from params with priority url / ? / #
			/map=([0-9\.]+)\/([-0-9\.]+)\/([-0-9\.]+)/, // map=<zoom>/<lon>/<lat>
			'zoom=$1&lon=$2&lat=$3' // zoom=<zoom>&lon=<lon>&lat=<lat>
		) +
		// Last values
		'zoom=' + localStorage.myol_zoom +
		'lon=' + localStorage.myol_lon +
		'lat=' + localStorage.myol_lat +
		// Default
		'zoom=6&lon=2&lat=47';

	if (options.display) {
		control.element.className = 'myol-permalink';
		aEl.innerHTML = 'Permalink';
		aEl.title = 'Generate a link with map zoom & position';
		control.element.appendChild(aEl);
	}

	function render(evt) {
		const view = evt.map.getView();

		// Set center & zoom at the init
		if (options.init) {
			options.init = false; // Only once

			view.setZoom(urlMod.match(/zoom=([0-9\.]+)/)[1]);

			view.setCenter(ol.proj.transform([
				urlMod.match(/lon=([-0-9\.]+)/)[1],
				urlMod.match(/lat=([-0-9\.]+)/)[1],
			], 'EPSG:4326', 'EPSG:3857'));
		}

		// Set the permalink with current map zoom & position
		if (view.getCenter()) {
			const ll4326 = ol.proj.transform(view.getCenter(), 'EPSG:3857', 'EPSG:4326'),
				newParams = 'map=' +
				(localStorage.myol_zoom = Math.round(view.getZoom() * 10) / 10) + '/' +
				(localStorage.myol_lon = Math.round(ll4326[0] * 10000) / 10000) + '/' +
				(localStorage.myol_lat = Math.round(ll4326[1] * 10000) / 10000);

			if (options.display)
				aEl.href = options.hash + newParams;

			if (options.setUrl)
				location.href = '#' + newParams;
		}
	}
	return control;
}

/**
 * Control to display the mouse position
 */
function controlMousePosition(options) {
	return new ol.control.MousePosition({
		projection: 'EPSG:4326',
		className: 'myol-coordinate',
		placeholder: String.fromCharCode(0), // Hide control when mouse is out of the map

		coordinateFormat: function(mouse) {
			if (ol.gpsValues && ol.gpsValues.position) {
				const ll4326 = ol.proj.transform(ol.gpsValues.position, 'EPSG:3857', 'EPSG:4326'),
					distance = ol.sphere.getDistance(mouse, ll4326);

				return distance < 1000 ?
					(Math.round(distance)) + ' m' :
					(Math.round(distance / 10) / 100) + ' km';
			} else
				return ol.coordinate.createStringXY(4)(mouse);
		},
		...options
	});
}

/**
 * Control to display the length of an hovered line
 * option hoverStyle style the hovered feature
 */
function controlLengthLine() {
	const control = controlButton();

	control.element.className = 'myol-length-line';

	control.setMap = function(map) {
		ol.control.Control.prototype.setMap.call(this, map);

		map.on('pointermove', evt => {
			control.element.innerHTML = ''; // Clear the measure if hover no feature

			// Find new features to hover
			map.forEachFeatureAtPixel(evt.pixel, calculateLength, {
				hitTolerance: 6, // Default is 0
			});
		});
	};

	function calculateLength(feature) {
		// Display the line length
		if (feature) {
			const length = ol.sphere.getLength(feature.getGeometry());

			if (length) {
				control.element.innerHTML =
					length < 1000 ?
					(Math.round(length)) + ' m' :
					(Math.round(length / 10) / 100) + ' km';

				return false; // Continue detection (for editor that has temporary layers)
			}
		}
	}
	return control;
}

/**
 * Control to display set preload of depth upper level tiles
 * This prepares the browser to become offline
 */
function controlTilesBuffer(opt) {
	const options = {
			depth: 3,
			...opt
		},
		control = controlButton();

	control.setMap = function(map) {
		ol.control.Control.prototype.setMap.call(this, map);

		// Action on each layer
		map.on('precompose', () => {
			map.getLayers().forEach(layer => {
				if (typeof layer.setPreload == 'function')
					layer.setPreload(options.depth);
			});
		});
	};

	return control;
}

/**
 * Geocoder
 * Requires https://github.com/jonataswalker/ol-geocoder/
 */
function controlGeocoder(options) {
	if (typeof Geocoder != 'function') // Vérify if geocoder is available
		return controlButton();

	const geocoder = new Geocoder('nominatim', {
			placeholder: 'Recherche par nom sur la carte', // Initialization of the input field
			...options
		}),
		controlEl = geocoder.element.firstElementChild;

	// Avoid submit of a form including the map
	geocoder.element.getElementsByTagName('input')[0]
		.addEventListener('keypress', evt =>
			evt.stopImmediatePropagation()
		);

	geocoder.on('addresschosen', evt =>
		evt.target.getMap().getView().fit(evt.bbox)
	);

	// Close other opened buttons when hover with a mouse
	geocoder.element.addEventListener('pointerover', () => {
		for (let el of document.getElementsByClassName('myol-button-selected'))
			el.classList.remove('myol-button-selected');
	});

	// Close submenu when hover another button
	document.addEventListener('pointerout', evt => {
		const hoveredEl = document.elementFromPoint(evt.x, evt.y);

		if (hoveredEl && hoveredEl.tagName == 'BUTTON')
			controlEl.classList.remove('gcd-gl-expanded');
	});

	return geocoder;
}

/**
 * Print control
 * Requires controlButton
 */
function controlPrint(options) {
	const control = controlButton({
		label: '&#x1F5A8;',
		className: 'myol-button-print',
		submenuHTML: '<p>Pour imprimer la carte:</p>' +
			'<p>-Choisir portrait ou paysage,</p>' +
			'<p>-zoomer et déplacer la carte dans le format,</p>' +
			'<p>-imprimer.</p>' +
			'<label><input type="radio" name="myol-po" value="0" ctrlonchange="resizeDraftPrint">Portrait A4</label>' +
			'<label><input type="radio" name="myol-po" value="1" ctrlonchange="resizeDraftPrint">Paysage A4</label>' +
			'<a onclick="printMap()">Imprimer</a>' +
			'<a onclick="location.reload()">Annuler</a>',
		...options
	});

	control.resizeDraftPrint = function() {
		const map = control.getMap(),
			mapEl = map.getTargetElement(),
			poElcs = document.querySelectorAll('input[name=myol-po]:checked'),
			orientation = poElcs.length ? parseInt(poElcs[0].value) : 0;

		mapEl.style.maxHeight = mapEl.style.maxWidth =
			mapEl.style.float = 'none';
		mapEl.style.width = orientation == 0 ? '208mm' : '295mm';
		mapEl.style.height = orientation == 0 ? '295mm' : '208mm';
		map.setSize([mapEl.clientWidth, mapEl.clientHeight]);

		// Set portrait / landscape
		const styleSheet = document.createElement('style');
		styleSheet.type = 'text/css';
		styleSheet.innerText = '@page {size: ' + (orientation == 0 ? 'portrait' : 'landscape') + '}';
		document.head.appendChild(styleSheet);

		// Hide all but the map
		document.body.appendChild(mapEl);
		for (let child = document.body.firstElementChild; child !== null; child = child.nextSibling)
			if (child.style && child !== mapEl)
				child.style.display = 'none';

		// Finer zoom not dependent on the baselayer's levels
		map.getView().setConstrainResolution(false);
		map.addInteraction(new ol.interaction.MouseWheelZoom({
			maxDelta: 0.1,
		}));

		// To return without print
		document.addEventListener('keydown', function(evt) {
			if (evt.key == 'Escape')
				setTimeout(function() { // Delay reload for FF & Opera
					location.reload();
				});
		});
	};

	printMap = function() {
		control.resizeDraftPrint();
		control.getMap().once('rendercomplete', function() {
			window.print();
			location.reload();
		});
	};

	return control;
}

/**
 * Help control
 * Requires controlButton
 * Display help contained in <TAG id="<options.submenuId>">
 */
function controlHelp(options) {
	return controlButton({
		label: '?',
		...options
	});
}

/**
 * Controls examples
 */
function controlsCollection(opt) {
	options = {
		supplementaryControls: [],
		...opt
	};

	return [
		// Top left
		new ol.control.Zoom(options.Zoom),
		new ol.control.FullScreen(options.FullScreen),
		controlGeocoder(options.Geocoder),
		controlGPS(options.GPS),
		controlLoadGPX(options.LoadGPX),
		controlDownload(options.Download),
		controlPrint(options.Print),
		controlHelp(options.Help),

		// Bottom left
		controlLengthLine(options.LengthLine),
		controlMousePosition(options.Mouseposition),
		new ol.control.ScaleLine(options.ScaleLine),

		// Bottom right
		controlPermalink(options.Permalink),
		new ol.control.Attribution(options.Attribution),

		...options.supplementaryControls
	];
}

/* FILE src/layerSwitcher.js */
/**
 * Layer switcher
 * Need to include layerSwitcher.css
 */

function controlLayerSwitcher(options) {
	const control = controlButton({
			className: 'myol-button-switcher',
			label: '&#x274F;',
			submenuHTML: '<div id="myol-ls-range">' +
				'<input type="range" title="Glisser pour faire varier la tranparence">' +
				'<span>Ctrl+click: multicouches</span>' +
				'</div>',
			render: render,
			...options
		}),
		baseLayers = Object.fromEntries(
			Object.entries(options.layers)
			.filter(([_, v]) => v != null) // Remove empty layers
		),
		layerNames = Object.keys(baseLayers),
		baselayer = location.href.match(/baselayer=([^\&]+)/);

	let transparentBaseLayerName,
		rangeContainerEl;

	// Get baselayer from url if any
	if (baselayer)
		localStorage.myol_baselayer = decodeURI(baselayer[1]);

	// HACK run when the control is attached to the map
	function render(evt) {
		if (!control.render) // Only once
			return;
		control.render = null;

		const map = evt.target;

		// Hide the selector when the cursor is out of the selector
		map.on('pointermove', function(evt) {
			const max_x = map.getTargetElement().offsetWidth - control.element.offsetWidth - 20,
				max_y = control.element.offsetHeight + 20;

			if (evt.pixel[0] < max_x || evt.pixel[1] > max_y)
				control.element.classList.remove('myol-button-switcher-open');
		});

		// Build html transparency slider
		rangeContainerEl = document.getElementById('myol-ls-range');
		rangeContainerEl.firstChild.oninput = displayTransparencyRange;

		// Build html baselayers selectors
		for (let name in baseLayers) {
			const labelEl = document.createElement('label');

			labelEl.innerHTML = '<input type="checkbox" value="' + name + '" ' + ' />' + name;
			labelEl.firstChild.onclick = selectBaseLayer;
			control.submenuEl.appendChild(labelEl);

			// Make all choices an array of layers
			if (!baseLayers[name].length)
				baseLayers[name] = [baseLayers[name]];

			// Mem it for further ops
			baseLayers[name].inputEl = labelEl.firstChild;

			// Display the selected layer
			for (let l = 0; l < baseLayers[name].length; l++) {
				baseLayers[name][l].setVisible(false); // Don't begin to get the tiles yet
				map.addLayer(baseLayers[name][l]);
			}
		}

		// Init layers
		displayBaseLayers();

		// Attach html additional selector
		const selectExtEl = document.getElementById(options.selectExtId);

		if (selectExtEl) {
			selectExtEl.classList.add('select-ext');
			control.submenuEl.appendChild(selectExtEl);
			// Unmask the selector if it has been @ the declaration
			selectExtEl.style.display = '';
		}
	}

	function selectBaseLayer(evt) {
		// Single layer
		if (!evt || !evt.ctrlKey || this.value == localStorage.myol_baselayer) {
			transparentBaseLayerName = '';
			localStorage.myol_baselayer = this.value;
		}
		// There is a second layer after the existing one
		else if (layerNames.indexOf(localStorage.myol_baselayer) <
			layerNames.indexOf(this.value)) {
			transparentBaseLayerName = this.value;
			// localStorage.myol_baselayer don't change
		}
		// There is a second layer before the existing one
		else {
			transparentBaseLayerName = localStorage.myol_baselayer;
			localStorage.myol_baselayer = this.value;
		}

		rangeContainerEl.firstChild.value = 50;
		displayBaseLayers();
	}

	function displayBaseLayers() {
		// Baselayer default is the first of the selection
		if (!baseLayers[localStorage.myol_baselayer])
			localStorage.myol_baselayer = layerNames[0];

		for (let name in baseLayers) {
			const visible =
				name == localStorage.myol_baselayer ||
				name == transparentBaseLayerName;

			// Write the checks
			baseLayers[name].inputEl.checked = visible;

			// Make the right layers visible
			for (let l = 0; l < baseLayers[name].length; l++) {
				baseLayers[name][l].setVisible(visible);
				baseLayers[name][l].setOpacity(1);
			}
		}

		displayTransparencyRange();
	}

	function displayTransparencyRange() {
		if (transparentBaseLayerName) {
			for (let l = 0; l < baseLayers[transparentBaseLayerName].length; l++)
				baseLayers[transparentBaseLayerName][l].setOpacity(
					rangeContainerEl.firstChild.value / 100
				);

			rangeContainerEl.className = 'myol-double-layer';
		} else
			rangeContainerEl.className = 'myol-single-layer';
	}

	return control;
}

/* FILE src/files.js */
/**
 * GPX file loader control
 * Requires controlButton
 */

function controlLoadGPX(options) {
	const control = controlButton({
		label: '&#x1F4C2;',
		submenuHTML: '<p>Importer un fichier au format GPX:</p>' +
			'<input type="file" accept=".gpx" ctrlOnChange="loadFile" />',
		...options
	});

	control.loadURL = async function(evt) {
		const xhr = new XMLHttpRequest();
		xhr.open('GET', evt.target.href);
		xhr.onreadystatechange = function() {
			if (xhr.readyState == 4 && xhr.status == 200)
				loadText(xhr.responseText);
		};
		xhr.send();
	};

	control.loadFile = function(evt) {
		const reader = new FileReader();

		if (evt.type == 'change' && evt.target.files)
			reader.readAsText(evt.target.files[0]);
		reader.onload = function() {
			loadText(reader.result);
		};
	};

	function loadText(text) {
		const map = control.getMap(),
			format = new ol.format.GPX(),
			features = format.readFeatures(text, {
				dataProjection: 'EPSG:4326',
				featureProjection: 'EPSG:3857',
			}),
			added = map.dispatchEvent({
				type: 'myol:onfeatureload', // Warn layerEditGeoJson that we uploaded some features
				features: features,
			});

		if (added !== false) { // If one used the feature
			// Display the track on the map
			const gpxSource = new ol.source.Vector({
					format: format,
					features: features,
				}),
				gpxLayer = new ol.layer.Vector({
					source: gpxSource,
					style: function(feature) {
						const properties = feature.getProperties(),
							styleOptions = {
								stroke: new ol.style.Stroke({
									color: 'blue',
									width: 3,
								}),
							};

						if (properties.sym)
							styleOptions.image = new ol.style.Icon({
								src: '//chemineur.fr/ext/Dominique92/GeoBB/icones/' + properties.sym + '.svg',
							});

						return new ol.style.Style(styleOptions);
					},
				});
			map.addLayer(gpxLayer);
		}

		// Zoom the map on the added features
		const extent = ol.extent.createEmpty();

		for (let f in features)
			ol.extent.extend(extent, features[f].getGeometry().getExtent());

		if (ol.extent.isEmpty(extent))
			alert('Fichier GPX vide');
		else
			map.getView().fit(extent, {
				maxZoom: 17,
				size: map.getSize(),
				padding: [5, 5, 5, 5],
			});

		// Close the submenu
		control.element.classList.remove('myol-display-submenu');
	}

	return control;
}

/**
 * File downloader control
 * Requires controlButton
 */
function controlDownload(opt) {
	const options = {
			label: '&#x1f4e5;',
			className: 'myol-button-download',
			submenuHTML: '<p>Cliquer sur un format ci-dessous pour obtenir un fichier ' +
				'contenant les éléments visibles dans la fenêtre:</p>' +
				'<a ctrlOnClick="download" id="GPX" mime="application/gpx+xml">GPX</a>' +
				'<a ctrlOnClick="download" id="KML" mime="vnd.google-earth.kml+xml">KML</a>' +
				'<a ctrlOnClick="download" id="GeoJSON" mime="application/json">GeoJSON</a>',
			fileName: document.title || 'openlayers',
			...opt
		},
		control = controlButton(options),
		hiddenEl = document.createElement('a');

	hiddenEl.target = '_self';
	hiddenEl.style = 'display:none';
	document.body.appendChild(hiddenEl);

	control.download = function(evt) {
		const formatName = evt.target.id,
			mime = evt.target.getAttribute('mime'),
			format = new ol.format[formatName](),
			map = control.getMap();
		let features = [],
			extent = map.getView().calculateExtent();

		// Get all visible features
		if (options.savedLayer)
			getFeatures(options.savedLayer);
		else
			map.getLayers().forEach(getFeatures);

		function getFeatures(savedLayer) {
			if (savedLayer.getSource() &&
				savedLayer.getSource().forEachFeatureInExtent) // For vector layers only
				savedLayer.getSource().forEachFeatureInExtent(extent, feature => {
					if (!savedLayer.getProperties().dragable) // Don't save the cursor
						features.push(feature);
				});
		}

		if (formatName == 'GPX')
			// Transform *Polygons in linestrings
			for (let f in features) {
				const geometry = features[f].getGeometry();

				if (geometry.getType().includes('Polygon')) {
					geometry.getCoordinates().forEach(coords => {
						if (typeof coords[0][0] == 'number')
							// Polygon
							features.push(new ol.Feature(new ol.geom.LineString(coords)));
						else
							// MultiPolygon
							coords.forEach(subCoords =>
								features.push(new ol.Feature(new ol.geom.LineString(subCoords)))
							);
					});
				}
			}

		const data = format.writeFeatures(features, {
				dataProjection: 'EPSG:4326',
				featureProjection: 'EPSG:3857',
				decimals: 5,
			})
			// Beautify the output
			.replace(/<[a-z]*>(0|null|[\[object Object\]|[NTZa:-]*)<\/[a-z]*>/g, '')
			.replace(/<Data name="[a-z_]*"\/>|<Data name="[a-z_]*"><\/Data>|,"[a-z_]*":""/g, '')
			.replace(/<Data name="copy"><value>[a-z_\.]*<\/value><\/Data>|,"copy":"[a-z_\.]*"/g, '')
			.replace(/(<\/gpx|<\/?wpt|<\/?trk>|<\/?rte>|<\/kml|<\/?Document)/g, '\n$1')
			.replace(/(<\/?Placemark|POINT|LINESTRING|POLYGON|<Point|"[a-z_]*":|})/g, '\n$1')
			.replace(/(<name|<ele|<sym|<link|<type|<rtept|<\/?trkseg|<\/?ExtendedData)/g, '\n\t$1')
			.replace(/(<trkpt|<Data|<LineString|<\/?Polygon|<Style)/g, '\n\t\t$1')
			.replace(/(<[a-z]+BoundaryIs)/g, '\n\t\t\t$1'),

			file = new Blob([data], {
				type: mime,
			});

		hiddenEl.download = options.fileName + '.' + formatName.toLowerCase();
		hiddenEl.href = URL.createObjectURL(file);
		hiddenEl.click();

		// Close the submenu
		control.element.classList.remove('myol-display-submenu');
	};

	return control;
}

/* FILE src/gps.js */
/**
 * GPS control
 * Requires controlButton
 */

function controlGPS(options) {
	const subMenu = location.href.match(/(https|localhost)/) ?
		'<p>Localisation GPS:</p>' +
		'<label>' +
		'<input type="radio" name="myol-gps-source" value="0" ctrlonchange="renderGPS" checked="checked" />' +
		'Inactif</label><label>' +
		'<input type="radio" name="myol-gps-source" value="1" ctrlonchange="renderGPS" />' +
		'Position GPS <span>(1) extérieur</span></label><label>' +
		'<input type="radio" name="myol-gps-source" value="2" ctrlonchange="renderGPS" />' +
		'Position GPS ou IP <span>(2) intérieur</span></label><hr><label>' +
		'<input type="radio" name="myol-gps-display" value="0" ctrlonchange="renderGPS" checked="checked" />' +
		'Graticule, carte libre</label><label>' +
		'<input type="radio" name="myol-gps-display" value="1" ctrlonchange="renderGPS" />' +
		'Centre la carte, nord en haut</label><label>' +
		'<input type="radio" name="myol-gps-display" value="2" ctrlonchange="renderGPS" />' +
		'Centre et oriente la carte <span>(3)</span></label>' +

		'<hr /><p>(1) plus précis en extérieur mais plus lent à initialiser, ' +
		'nécessite un capteur et une réception GPS.</p>' +
		'<p>(2) plus précis et rapide en intérieur ou en zone urbaine ' +
		'mais peut être très erroné en extérieur à l&apos;initialisation. ' +
		'Utilise les position des points WiFi proches en plus du GPS dont il peut se passer.</p>' +
		'<p>(3) nécessite un capteur magnétique et un explorateur le supportant.</p>' :

		// Si on est en http
		'<p>L&apos;utilisation du GPS nécessite https</p>' +
		'<a href="' + document.location.href.replace('http:', 'https:') + '">Passer en https<a>',

		// Display status, altitude & speed
		control = controlButton({
			className: 'myol-button-gps',
			label: '&#x2295;',
			submenuHTML: subMenu,
			...options
		}),

		// Graticule
		graticuleFeature = new ol.Feature(),
		northGraticuleFeature = new ol.Feature(),
		graticuleLayer = new ol.layer.Vector({
			source: new ol.source.Vector({
				features: [graticuleFeature, northGraticuleFeature],
			}),
			zIndex: 20, // Above the features
			style: new ol.style.Style({
				fill: new ol.style.Fill({
					color: 'rgba(128,128,255,0.2)',
				}),
				stroke: new ol.style.Stroke({
					color: '#20b',
					lineDash: [16, 14],
					width: 1,
				}),
			}),
		}),
		statusEl = document.createElement('p');

	control.element.appendChild(statusEl);

	graticuleFeature.setStyle(new ol.style.Style({
		stroke: new ol.style.Stroke({
			color: '#000',
			lineDash: [16, 14],
			width: 1,
		}),
	}));

	northGraticuleFeature.setStyle(new ol.style.Style({
		stroke: new ol.style.Stroke({
			color: '#c00',
			lineDash: [16, 14],
			width: 1,
		}),
	}));

	let geolocation;
	ol.gpsValues = {}; // Store the measures for internal use & other controls

	control.setMap = function(map) {
		ol.control.Control.prototype.setMap.call(this, map);

		map.addLayer(graticuleLayer);
		map.on('moveend', control.renderGPS); // Refresh graticule after map zoom

		geolocation = new ol.Geolocation({
			projection: map.getView().getProjection(),
			trackingOptions: {
				enableHighAccuracy: true,
				maximumAge: 1000,
				timeout: 1000,
				...options
			},
		});
		geolocation.on('change', control.renderGPS);
		geolocation.on('error', function(error) {
			console.log('Geolocation error: ' + error.message);
		});

		// Browser heading from the inertial & magnetic sensors
		window.addEventListener('deviceorientationabsolute', function(evt) {
			ol.gpsValues.heading = evt.alpha || evt.webkitCompassHeading; // Android || iOS
			control.renderGPS(evt);
		});
	};

	// Trigered by <input ... ctrlOnChange="renderGPS" />
	control.renderGPS = function(evt) {
		const sourceLevelEl = document.querySelector('input[name="myol-gps-source"]:checked'),
			displayLevelEl = document.querySelector('input[name="myol-gps-display"]:checked'),
			displayEls = document.getElementsByName('myol-gps-display'),
			sourceLevel = sourceLevelEl ? parseInt(sourceLevelEl.value) : 0, // On/off, GPS, GPS&WiFi
			displayLevel = displayLevelEl ? parseInt(displayLevelEl.value) : 0, // Graticule & sourceLevel
			map = control.getMap(),
			view = map ? map.getView() : null;

		// Tune the tracking level
		if (evt.target.name == 'myol-gps-source') {
			geolocation.setTracking(sourceLevel > 0);
			graticuleLayer.setVisible(false);
			ol.gpsValues = {}; // Reset the values
			if (!sourceLevel)
				displayEls[0].checked = true;
			if (sourceLevel && displayLevel == 0)
				displayEls[2].checked = true;
		}

		// Get geolocation values
		['Position', 'AccuracyGeometry', 'Speed', 'Altitude'].forEach(valueName => {
			const value = geolocation['get' + valueName]();
			if (value)
				ol.gpsValues[valueName.toLowerCase()] = value;
		});

		// State 1 only takes positions from the GPS (which have an altitude)
		if (sourceLevel == 1 && !ol.gpsValues.altitude)
			ol.gpsValues.position = null;

		// Render position & graticule
		if (map && view && sourceLevel && ol.gpsValues.position) {
			// Estimate the viewport size to draw a visible graticule
			const p = ol.gpsValues.position,
				hg = map.getCoordinateFromPixel([0, 0]),
				bd = map.getCoordinateFromPixel(map.getSize()),
				far = Math.hypot(hg[0] - bd[0], hg[1] - bd[1]) * 10,
				// The graticule
				geometry = [
					new ol.geom.MultiLineString([
						[
							[p[0] - far, p[1]],
							[p[0] + far, p[1]]
						],
						[
							[p[0], p[1]],
							[p[0], p[1] - far]
						],
					]),
				],
				// Color north in red
				northGeometry = [
					new ol.geom.LineString([
						[p[0], p[1]],
						[p[0], p[1] + far]
					]),
				];

			// The accuracy circle
			if (ol.gpsValues.accuracygeometry)
				geometry.push(ol.gpsValues.accuracygeometry);

			graticuleFeature.setGeometry(new ol.geom.GeometryCollection(geometry));
			northGraticuleFeature.setGeometry(new ol.geom.GeometryCollection(northGeometry));

			// Center the map
			if (displayLevel > 0)
				view.setCenter(p);

			// Orientation
			if (!sourceLevel || displayLevel == 1)
				view.setRotation(0);
			else if (ol.gpsValues.heading && displayLevel == 2)
				view.setRotation(
					Math.PI / 180 * (ol.gpsValues.heading - screen.orientation.angle) // Delivered ° reverse clockwize
				);

			// Zoom on the area
			if (!ol.gpsValues.isZoomed) { // Only the first time after activation
				ol.gpsValues.isZoomed = true;
				view.setZoom(17);

				// Close submenu when GPS locates
				control.element.classList.remove('myol-button-hover');
				control.element.classList.remove('myol-button-selected');
			}
			graticuleLayer.setVisible(true);
		} else
			view.setRotation(0); // Return to inactive state

		// Display data under the button
		let status = ol.gpsValues.position ? '' : 'Sync...';
		if (ol.gpsValues.altitude) {
			status = Math.round(ol.gpsValues.altitude) + ' m';
			if (ol.gpsValues.speed)
				status += ' ' + (Math.round(ol.gpsValues.speed * 36) / 10) + ' km/h';
		}
		if (statusEl)
			statusEl.innerHTML = sourceLevel ? status : '';

		// Close the submenu
		if (evt.target.name) // Only when an input is hit
			control.element.classList.remove('myol-display-submenu');
	};

	return control;
}

/* FILE src/marker.js */
/**
 * Marker position display & edit
 * Options:
   src : url of the marker image
   prefix : id prefix of input/output values
   focus : center & zoom on the marker
   dragable : can draw the marker to edit position
 */

function layerMarker(opt) {
	const options = {
			position: [0, 0],
			...opt
		},
		els = [],
		point = new ol.geom.Point(options.position),
		source = new ol.source.Vector({
			features: [new ol.Feature(point)],
		}),
		layer = new ol.layer.Vector({
			source: source,
			zIndex: 20, // Above points (zIndex = 10)
			style: new ol.style.Style({
				image: new ol.style.Icon({
					anchor: [0.5, 0.5],
					src: options.src,
				}),
			}),
			...options
		});

	// Initialise specific projection
	if (typeof proj4 == 'function') {
		// Swiss
		proj4.defs('EPSG:21781',
			'+proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 ' +
			'+k_0=1 +x_0=600000 +y_0=200000 +ellps=bessel ' +
			'+towgs84=660.077,13.551,369.344,2.484,1.783,2.939,5.66 +units=m +no_defs'
		);

		// UTM zones
		for (let u = 1; u <= 60; u++) {
			proj4.defs('EPSG:' + (32600 + u), '+proj=utm +zone=' + u + ' +ellps=WGS84 +datum=WGS84 +units=m +no_defs');
			proj4.defs('EPSG:' + (32700 + u), '+proj=utm +zone=' + u + ' +ellps=WGS84 +datum=WGS84 +units=m +no_defs');
		}

		ol.proj.proj4.register(proj4);
	}

	// Collect all entries elements
	['json', 'lon', 'lat', 'x', 'y', 'coordinates', 'select', 'string'].forEach(i => {
		els[i] = document.getElementById((options.prefix || 'marker') + '-' + i) || document.createElement('div');
		els[i].onchange = onChange;
	});

	// Initialise position with existing entries values
	els.lon.onchange();
	els.json.onchange();

	// Read new values
	function onChange(evt) {
		if (evt) // If a field has changed
			// Mark last change time to be able to reload vector layer if changed
			sessionStorage.myol_lastChangeTime = Date.now();

		// Find changed input type from tne input id
		const idMatch = this.id.match(/-([a-z]+)/);
		if (idMatch)
			switch (idMatch[1]) {
				case 'json':
					const json = (els.json.value).match(/([-0-9\.]+)[, ]*([-0-9\.]+)/);
					if (json)
						changeLL(json.slice(1), 'EPSG:4326', true);
					break;
				case 'lon':
				case 'lat':
					changeLL([els.lon.value, els.lat.value], 'EPSG:4326', true);
					break;
				case 'x':
				case 'y':
					if (typeof proj4 == 'function') // x | y
						changeLL([parseInt(els.x.value), parseInt(els.y.value)], 'EPSG:21781', true);
					break;
			}
	}

	layer.setMapInternal = function(map) {
		map.once('loadstart', () => { // Hack to be noticed at map init
			const pc = point.getCoordinates(),
				view = map.getView();

			// Focus map on the marker
			if (options.focus) {
				if (pc[0] && pc[1])
					view.setCenter(pc);
				else
					// If no position given, put the marker on the center of the visible map
					changeLL(view.getCenter(), 'EPSG:3857', view);

				view.setZoom(options.focus);
			}

			// Edit the marker position
			if (options.dragable) {
				// Drag the marker
				map.addInteraction(new ol.interaction.Pointer({
					handleDownEvent: function(evt) {
						// Mark last change time
						sessionStorage.myol_lastChangeTime = Date.now();

						return map.getFeaturesAtPixel(evt.pixel, {
							layerFilter: function(l) {
								return l.ol_uid == layer.ol_uid;
							}
						}).length;
					},
					handleDragEvent: function(evt) {
						changeLL(evt.coordinate, 'EPSG:3857', view);
					},
				}));

				// Get the marker at the dblclick position
				map.on('dblclick', function(evt) {
					changeLL(evt.coordinate, 'EPSG:3857', view);
					return false;
				});
			}
		});
	};

	// Display values
	function changeLL(ll, projection, focus, view) {
		if (ll[0] && ll[1]) {
			// Wrap +-180°
			const bounds = ol.proj.transform([180, 85], 'EPSG:4326', projection);

			ll[0] -= Math.round(ll[0] / bounds[0] / 2) * bounds[0] * 2;

			const ll3857 = ol.proj.transform(ll, projection, 'EPSG:3857'),
				ll4326 = ol.proj.transform(ll, projection, 'EPSG:4326');

			// Move the marker
			point.setCoordinates(ll3857);

			// Move the map
			if (focus && view)
				view.setCenter(ll3857);

			// Populate inputs
			els.lon.value = Math.round(ll4326[0] * 100000) / 100000;
			els.lat.value = Math.round(ll4326[1] * 100000) / 100000;
			els.json.value = '{"type":"Point","coordinates":[' + els.lon.value + ',' + els.lat.value + ']}';

			// Display
			const strings = {
				dec: 'Lon: ' + els.lon.value + ', Lat: ' + els.lat.value,
				dms: ol.coordinate.toStringHDMS(ll4326),
			};

			if (typeof proj4 == 'function') {
				// UTM zones
				const z = Math.floor(ll4326[0] / 6 + 90) % 60 + 1,
					u = 32600 + z + (ll4326[1] < 0 ? 100 : 0),
					llutm = ol.proj.transform(ll, projection, 'EPSG:' + u);

				// Swiss
				const ll21781 = ol.proj.transform(ll, projection, 'EPSG:21781');
				els.x.value = Math.round(ll21781[0]);
				els.y.value = Math.round(ll21781[1]);

				// Display
				strings.swiss = 'X=' + els.x.value + ', Y=' + els.y.value + ' (CH1903)';
				strings.utm = ' UTM ' + z +
					' E:' + Math.round(llutm[0]) + ' ' +
					(llutm[1] > 0 ? 'N:' : 'S:') + Math.round(llutm[1] + (llutm[1] > 0 ? 0 : 10000000));

				// Hide Swiss coordinates when out of extent
				const epsg21781 = ol.extent.containsCoordinate([664577, 5753148, 1167741, 6075303], ll3857);

				els.coordinates.classList[epsg21781 ? 'add' : 'remove']('epsg21781');

				if (!epsg21781 && els.select.value == 'swiss')
					els.select.value = 'dec';
			}

			// Display selected format
			els.string.textContent = strings[els.select.value || 'dec'];
		}
	}

	return layer;
}

/* FILE src/editor.js */
/**
 * geoJson lines & polygons edit
 * Requires JSONparse, controlButton (from src/controls.js)
 */

function layerEditGeoJson(opt) {
	const options = {
			format: new ol.format.GeoJSON(),
			projection: 'EPSG:3857',
			geoJsonId: 'editable-json', // Option geoJsonId : html element id of the geoJson features to be edited
			focus: false, // Zoom the map on the loaded features
			snapLayers: [], // Vector layers to snap on
			help: ['Modification', 'New line', 'New polygon'],
			readFeatures: function() {
				return options.format.readFeatures(
					options.geoJson ||
					JSONparse(geoJsonValue || '{"type":"FeatureCollection","features":[]}'), {
						featureProjection: options.projection,
					});
			},
			saveFeatures: function(coordinates, format) {
				return format.writeFeatures(
						source.getFeatures(
							coordinates, format), {
							featureProjection: options.projection,
							decimals: 5,
						})
					.replace(/"properties":\{[^\}]*\}/, '"properties":null');
			},
			// Drag lines or Polygons
			styleOptions: {
				// Lines or polygons border
				stroke: new ol.style.Stroke({
					color: 'red',
					width: 2,
				}),
				// Polygons
				fill: new ol.style.Fill({
					color: 'rgba(0,0,255,0.2)',
				}),
			},
			// Hover / modify / create
			editStyleOptions: {
				// Edit position marker
				image: new ol.style.Circle({
					radius: 4,
					stroke: new ol.style.Stroke({
						color: 'red',
						width: 2,
					}),
				}),
				// Lines or polygons border
				stroke: new ol.style.Stroke({
					color: 'red',
					width: 4,
				}),
				// Polygons
				fill: new ol.style.Fill({
					color: 'rgba(255,0,0,0.3)',
				}),
			},
			...opt
		},

		labels = ['&#x1F58D;', '&#xD17;', '&#X23E2;'], // Modify, Line, Polygon
		control = controlButton({
			className: 'myol-button-edit',
			label: 'E', // To be defined by changeModeEdit
			submenuHTML: '<p>Edition:</p>' +
				'<label for="myol-edit0">' +
				'<input type="radio" name="myol-edit" id="myol-edit0" value="0" ctrlOnChange="changeModeEdit" />' +
				'Modification &#x1F58D;' +
				'</label>' +
				(!options.help[1] ? '' :
					'<label for="myol-edit1">' +
					'<input type="radio" name="myol-edit" id="myol-edit1" value="1" ctrlOnChange="changeModeEdit" />' +
					'Création ligne &#xD17;' +
					'</label>') +
				(!options.help[2] ? '' :
					'<label for="myol-edit2">' +
					'<input type="radio" name="myol-edit" id="myol-edit2" value="2" ctrlOnChange="changeModeEdit" />' +
					'Création polygone &#X23E2;' +
					'</label>') +
				'<hr/><div id="myol-help-edit"></div>',
		}),

		geoJsonEl = document.getElementById(options.geoJsonId), // Read data in an html element
		geoJsonValue = geoJsonEl ? geoJsonEl.value : '',
		displayStyle = new ol.style.Style(options.styleOptions),
		editStyle = new ol.style.Style(options.editStyleOptions),

		features = options.readFeatures(),
		source = new ol.source.Vector({
			features: features,
			wrapX: false,
		}),
		layer = new ol.layer.Vector({
			source: source,
			zIndex: 20, // Editor & cursor : above the features
			style: displayStyle,
		}),

		interactions = [
			new ol.interaction.Modify({ // 0 Modify
				source: source,
				pixelTolerance: 16, // Default is 10
				style: editStyle,
			}),
			new ol.interaction.Draw({ // 1 drawLine
				style: editStyle,
				source: source,
				stopClick: true, // Avoid zoom when you finish drawing by doubleclick
				type: 'LineString',
			}),
			new ol.interaction.Draw({ // 2 drawPoly
				style: editStyle,
				source: source,
				stopClick: true, // Avoid zoom when you finish drawing by doubleclick
				type: 'Polygon',
			}),
			new ol.interaction.Snap({ // 3 snap
				source: source,
				pixelTolerance: 7.5, // 6 + line width / 2 : default is 10
			}),
		];

	// Manage hover to save modify actions integrity
	let hoveredFeature = null;

	control.layer = layer; // For user's usage

	control.setMap = function(map) {
		ol.control.Control.prototype.setMap.call(this, map);

		optimiseEdited(); // Treat the geoJson input as any other edit
		map.addLayer(layer);
		control.changeModeEdit(); // Display button & help

		// Zoom the map on the loaded features
		if (options.focus && features.length) {
			const extent = ol.extent.createEmpty(); // For focus on all features calculation

			for (let f in features)
				ol.extent.extend(extent, features[f].getGeometry().getExtent());

			map.getView().fit(extent, {
				maxZoom: options.focus,
				size: map.getSize(),
				padding: [5, 5, 5, 5],
			});
		}

		// Add features loaded from GPX file
		map.on('myol:onfeatureload', evt => {
			source.addFeatures(evt.features);
			optimiseEdited();
			return false; // Warn controlLoadGPX that the editor got the included feature
		});

		map.on('pointermove', hover);
	};

	control.changeModeEdit = evt => {
		const level = evt ? evt.target.value : 0,
			chidEls = control.element.children,
			inputEditEl = document.getElementById('myol-edit' + level),
			helpEditEl = document.getElementById('myol-help-edit');

		// Change button
		if (chidEls)
			chidEls[0].innerHTML = labels[level];

		// Change button
		if (inputEditEl)
			inputEditEl.checked = true;

		// Change specific help
		if (helpEditEl)
			helpEditEl.innerHTML = options.help[level];

		// Replace interactions
		interactions.forEach(i => control.getMap().removeInteraction(i));
		control.getMap().addInteraction(interactions[level]); // Add active interaction
		control.getMap().addInteraction(interactions[3]); // Snap must be added after the others
	};

	// End of modify
	interactions[0].on('modifyend', evt => {

		// Mark last change time
		sessionStorage.myol_lastChangeTime = Date.now();

		// Ctrl+Alt+click on segment : delete the line or poly
		if (evt.mapBrowserEvent.originalEvent.ctrlKey &&
			evt.mapBrowserEvent.originalEvent.altKey) {
			const selectedFeatures = control.getMap().getFeaturesAtPixel(
				evt.mapBrowserEvent.pixel, {
					hitTolerance: 6, // Default is 0
					layerFilter: l => {
						return l.ol_uid == layer.ol_uid;
					}
				});

			for (let f in selectedFeatures) // We delete the selected feature
				source.removeFeature(selectedFeatures[f]);
		}

		// Alt+click on segment : delete the segment & split the line
		const newFeature = interactions[3].snapTo(
			evt.mapBrowserEvent.pixel,
			evt.mapBrowserEvent.coordinate,
			interactions[3].getMap()
		);

		if (evt.mapBrowserEvent.originalEvent.altKey && newFeature)
			optimiseEdited(newFeature.vertex);

		// Finish
		optimiseEdited();
		hoveredFeature = null; // Recover hovering
	});

	// End of line & poly drawing
	[1, 2].forEach(i => interactions[i].on('drawend', () => {
		// Warn source 'on change' to save the feature
		// Don't do it now as it's not yet added to the source
		source.modified = true;

		// Reset interaction & button to modify
		control.changeModeEdit();
	}));

	// Snap on vector layers
	options.snapLayers.forEach(layer => {
		layer.getSource().on('change', () => {
			const fs = layer.getSource().getFeatures();
			for (let f in fs)
				interactions[3].addFeature(fs[f]);
		});
	});

	// End of feature creation
	source.on('change', () => { // Call all sliding long
		if (source.modified) { // Awaiting adding complete to save it
			source.modified = false; // To avoid loops

			// Finish
			optimiseEdited();
			hoveredFeature = null; // Recover hovering
		}
	});

	function hover(evt) {
		let nbFeaturesAtPixel = 0;
		control.getMap().forEachFeatureAtPixel(evt.pixel, feature => {
			source.getFeatures().forEach(f => {
				if (f.ol_uid == feature.ol_uid) {
					nbFeaturesAtPixel++;
					if (!hoveredFeature) { // Hovering only one
						feature.setStyle(editStyle);
						hoveredFeature = feature; // Don't change it until there is no more hovered
					}
				}
			});
		}, {
			hitTolerance: 6, // Default is 0
		});

		// If no more hovered, return to the normal style
		if (!nbFeaturesAtPixel && !evt.originalEvent.buttons && hoveredFeature) {
			hoveredFeature.setStyle(displayStyle);
			hoveredFeature = null;
		}
	}

	function optimiseEdited(deleteCoords) {
		const coordinates = optimiseFeatures(
			source.getFeatures(),
			options.help[1],
			options.help[2],
			true,
			true,
			deleteCoords
		);

		// Recreate features
		source.clear();

		for (let l in coordinates.lines)
			source.addFeature(new ol.Feature({
				geometry: new ol.geom.LineString(coordinates.lines[l]),
			}));
		for (let p in coordinates.polys)
			source.addFeature(new ol.Feature({
				geometry: new ol.geom.Polygon(coordinates.polys[p]),
			}));

		// Save geometries in <EL> as geoJSON at every change
		if (geoJsonEl)
			geoJsonEl.value = options.saveFeatures(coordinates, options.format);
	}

	// Refurbish Lines & Polygons
	// Split lines having a summit at deleteCoords
	function optimiseFeatures(features, withLines, withPolygons, merge, holes, deleteCoords) {
		const points = [],
			lines = [],
			polys = [];

		// Get all edited features as array of coordinates
		for (let f in features)
			flatFeatures(features[f].getGeometry(), points, lines, polys, deleteCoords);

		for (let a in lines)
			// Exclude 1 coordinate features (points)
			if (lines[a].length < 2)
				delete lines[a];

			// Merge lines having a common end
			else if (merge)
			for (let b = 0; b < a; b++) // Once each combination
				if (lines[b]) {
					const m = [a, b];
					for (let i = 4; i; i--) // 4 times
						if (lines[m[0]] && lines[m[1]]) { // Test if the line has been removed
							// Shake lines end to explore all possibilities
							m.reverse();
							lines[m[0]].reverse();
							if (compareCoords(lines[m[0]][lines[m[0]].length - 1], lines[m[1]][0])) {
								// Merge 2 lines having 2 ends in common
								lines[m[0]] = lines[m[0]].concat(lines[m[1]].slice(1));
								delete lines[m[1]]; // Remove the line but don't renumber the array keys
							}
						}
				}

		// Make polygons with looped lines
		for (let a in lines)
			if (withPolygons && // Only if polygons are autorized
				lines[a]) {
				// Close open lines
				if (!withLines) // If only polygons are autorized
					if (!compareCoords(lines[a]))
						lines[a].push(lines[a][0]);

				if (compareCoords(lines[a])) { // If this line is closed
					// Split squeezed polygons
					// Explore all summits combinaison
					for (let i1 = 0; i1 < lines[a].length - 1; i1++)
						for (let i2 = 0; i2 < i1; i2++)
							if (lines[a][i1][0] == lines[a][i2][0] &&
								lines[a][i1][1] == lines[a][i2][1]) { // Find 2 identical summits
								let squized = lines[a].splice(i2, i1 - i2); // Extract the squized part
								squized.push(squized[0]); // Close the poly
								polys.push([squized]); // Add the squized poly
								i1 = i2 = lines[a].length; // End loop
							}

					// Convert closed lines into polygons
					polys.push([lines[a]]); // Add the polygon
					delete lines[a]; // Forget the line
				}
			}

		// Makes holes if a polygon is included in a biggest one
		for (let p1 in polys) // Explore all Polygons combinaison
			if (holes && // Make holes option
				polys[p1]) {
				const fs = new ol.geom.Polygon(polys[p1]);
				for (let p2 in polys)
					if (polys[p2] && p1 != p2) {
						let intersects = true;
						for (let c in polys[p2][0])
							if (!fs.intersectsCoordinate(polys[p2][0][c]))
								intersects = false;
						if (intersects) { // If one intersects a bigger
							polys[p1].push(polys[p2][0]); // Include the smaler in the bigger
							delete polys[p2]; // Forget the smaller
						}
					}
			}

		return {
			points: points,
			lines: lines.filter(Boolean), // Remove deleted array members
			polys: polys.filter(Boolean),
		};
	}

	function flatFeatures(geom, points, lines, polys, deleteCoords) {
		// Expand geometryCollection
		if (geom.getType() == 'GeometryCollection') {
			const geometries = geom.getGeometries();
			for (let g in geometries)
				flatFeatures(geometries[g], points, lines, polys, deleteCoords);
		}
		// Point
		else if (geom.getType().match(/point$/i))
			points.push(geom.getCoordinates());

		// line & poly
		else
			// Get lines or polyons as flat array of coordinates
			flatCoord(lines, geom.getCoordinates(), deleteCoords);
	}

	// Get all lines fragments (lines, polylines, polygons, multipolygons, hole polygons, ...)
	// at the same level & split if one point = deleteCoords
	function flatCoord(existingCoords, newCoords, deleteCoords) {
		if (typeof newCoords[0][0] == 'object') // Multi*
			for (let c1 in newCoords)
				flatCoord(existingCoords, newCoords[c1], deleteCoords);
		else {
			existingCoords.push([]); // Add a new segment

			for (let c2 in newCoords)
				if (deleteCoords && compareCoords(newCoords[c2], deleteCoords))
					existingCoords.push([]); // Ignore this point and add a new segment
				else
					// Stack on the last existingCoords array
					existingCoords[existingCoords.length - 1].push(newCoords[c2]);
		}
	}

	function compareCoords(a, b) {
		if (!a)
			return false;
		if (!b)
			return compareCoords(a[0], a[a.length - 1]); // Compare start with end
		return a[0] == b[0] && a[1] == b[1]; // 2 coordinates
	}

	return control;
}